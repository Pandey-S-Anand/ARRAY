//Bruteforce Approach

class Solution {
    public int maxProfit(int[] prices) {
        return calculateMaxProfit(0, prices, true);
    }

    private int calculateMaxProfit(int index, int[] prices, boolean canBuy) {
        if (index >= prices.length) {
            return 0;
        }

        if (canBuy) {
            int buyStock = -prices[index] + calculateMaxProfit(index + 1, prices, false);
            int skipBuy = calculateMaxProfit(index + 1, prices, true);
            return Math.max(buyStock, skipBuy);
        }

        int sellStock = prices[index] + calculateMaxProfit(index + 2, prices, true);
        int skipSell = calculateMaxProfit(index + 1, prices, false);
        return Math.max(sellStock, skipSell);
    }
}


//Better Approach

class Solution {
    private int[][] memo;

    public int maxProfit(int[] prices) {
        memo = new int[prices.length][2];
        initializeMemo();
        return calculateMaxProfit(0, prices, 1);
    }

    private int calculateMaxProfit(int index, int[] prices, int canBuy) {
        if (index >= prices.length) {
            return 0;
        }

        if (memo[index][canBuy] != -1) {
            return memo[index][canBuy];
        }

        if (canBuy == 1) {
            int buyStock = -prices[index] + calculateMaxProfit(index + 1, prices, 0);
            int skipBuy = calculateMaxProfit(index + 1, prices, 1);
            return memo[index][canBuy] = Math.max(buyStock, skipBuy);
        }

        int sellStock = prices[index] + calculateMaxProfit(index + 2, prices, 1);
        int skipSell = calculateMaxProfit(index + 1, prices, 0);
        return memo[index][canBuy] = Math.max(sellStock, skipSell);
    }

    private void initializeMemo() {
        for (int i = 0; i < memo.length; i++) {
            Arrays.fill(memo[i], -1);
        }
    }
}


//Optimal Approach

/*
 * When deciding between forward and backward iteration in dynamic programming problems,
 * the key factor to consider is state dependencies.
 * 
 * Backward iteration is often more appropriate when the current state's decision
 * influences future states, particularly in problems with cooldown periods
 * where selling today affects the options available for the next two days.
 * 
 * Conversely, forward iteration can be used even when referencing future states
 * (like indices i+1 or i+2), as long as these references do not create dependencies
 * that influence the current state's decisions.
 */


//Naive Implementation

class Solution {
    public int maxProfit(int[] prices) {
        /*
         * dp[day][canBuy] represents the maximum profit achievable from the current day
         * (i.e., 'day') up to the last day (prices.length - 1) given the following condition:
         * 
         * - If canBuy = 1: This indicates that we are allowed to buy stock on the current day. We have two choices:
         * 1. Buy the stock: This will decrease our profit by the current stock price (incurs a cost) and 
         *    switch us to a state where we cannot buy (canBuy = 0) on the next day.
         * 2. Skip buying the stock: This keeps our current profit unchanged and allows us to consider buying on the next day.
         * 
         * - If canBuy = 0: This means we are only allowed to sell the stock on the current day. Here, we also have two choices:
         * 1. Sell the stock: This will increase our profit by the current stock price. 
         *    Following a sale, there is a 1-day cooldown period, which means we can only buy again (canBuy = 1) after skipping the next day.
         * 2. Skip selling the stock: This keeps our profit as it was the previous day,  allowing us to reconsider selling on the next day.
         */

        int[][] dp = new int[prices.length + 2][2];

        dp[prices.length][0] = 0;
        dp[prices.length][1] = 0;
        dp[prices.length + 1][0] = 0;
        dp[prices.length + 1][1] = 0;

        for (int day = prices.length - 1; day >= 0; day--) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                int profit = 0;
                if (canBuy == 1) {
                    int buyStock = -prices[day] + dp[day + 1][0];
                    int skipBuy = dp[day + 1][1];
                    profit = Math.max(buyStock, skipBuy);
                } else {
                    int sellStock = prices[day] + dp[day + 2][1];
                    int skipSell = dp[day + 1][0];
                    profit = Math.max(sellStock, skipSell);
                }
                dp[day][canBuy] = profit;
            }
        }
        /*
         * Return the maximum profit obtainable starting from the first day to the last
         * trading day, with the option to buy. This indicates that you have the opportunity to buy
         * at the end of the trading days, reflecting the completion of all transactions up to that point.
         */
        return dp[0][1];
    }
}


//Optimal Implementation

class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length + 2][2];

        for (int day = prices.length - 1; day >= 0; day--) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                if (canBuy == 1) {
                    dp[day][canBuy] = Math.max(-prices[day] + dp[day + 1][0], dp[day + 1][1]);
                } else {
                    dp[day][canBuy] = Math.max(prices[day] + dp[day + 2][1], dp[day + 1][0]);
                }
            }
        }

        return dp[0][1];
    }
}


//Aliter (space optimised)

class Solution {
    public int maxProfit(int[] prices) {
        int[] currentDay = new int[2];
        int[] nextDay = new int[2];
        int[] nextNextDay = new int[2];

        for (int day = prices.length - 1; day >= 0; day--) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                if (canBuy == 1) {
                    currentDay[canBuy] = Math.max(-prices[day] + nextDay[0], nextDay[1]);
                } else {
                    currentDay[canBuy] = Math.max(prices[day] + nextNextDay[1], nextDay[0]);
                }
            }

            int[] temp = nextNextDay;
            nextNextDay = nextDay;
            nextDay = currentDay;
            currentDay = temp;
        }

        return nextDay[1];
    }
}
