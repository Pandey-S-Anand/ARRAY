/*
What if we dont sort the subset before storing ?

Ex: arr[]= [[4,4,4,1,4]

[]

[4]

[4]      //REMOVED COZ OF CHECK
[4, 4]

[4].    //REMOVED COZ OF CHECK
[4, 4]  //REMOVED COZ OF CHECK
[4, 4, 4]

[1]
[4, 1]
[4, 4, 1]
[4, 4, 4 ,1]

[4]  //REMOVED COZ OF CHECK
[4 , 4] //REMOVED COZ OF CHECK
[4, 4, 4] //REMOVED COZ OF CHECK
[4, 4, 4, 4]
[1, 4]
[4, 1, 4]
[4, 4, 1, 4]
[4, 4, 4, 1, 4]

(On observation : [1, 4] , [4, 1, 4] and  [4, 4, 1, 4] are duplicates )
*/

//Iterative Approach

// Method 1

//Intuitive Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());

        for (int i = 0; i < arr.length; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> subset = new ArrayList<>(subsets.get(j));
                subset.add(arr[i]);
                Collections.sort(subset);
                if (!subsets.contains(subset)) {
                    subsets.add(subset);
                }
            }
        }

        return subsets;
    }
}


//Optimal Implementation





//Bruteforce Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
         Arrays.sort(arr);
         List<List<Integer> > res = new ArrayList<>();
         List<Integer>subset=new ArrayList<Integer>();
         Set<List<Integer>>hs= new HashSet<>();

         generateUniqueSubsets(arr,arr.length,0,subset,hs);
       
         for(List<Integer>l :hs)
           res.add(l);
       
         return res;    
    }

    public void generateUniqueSubsets(int[] arr,int n,int arrIdx,List<Integer>ss,Set<List<Integer>>hs)
    {
        if(arrIdx==n)
          hs.add(new ArrayList<Integer>(ss));
        else
        {
          //Include element
          ss.add(arr[arrIdx]);
          generateUniqueSubsets(arr,n,arrIdx+1,ss,hs);
          //Exclude Element
          ss.remove(ss.size()-1);
          generateUniqueSubsets(arr,n,arrIdx+1,ss,hs); 
        }
    }
}


//Better Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> res = new ArrayList<>();
        List<Integer>subset=new ArrayList<>();
       
	generateUniqueSubsets(arr,arr.length,0,subset,res);

      return res;   
    }

    public void generateUniqueSubsets(int[] arr,int n,int arrIdx,List<Integer>ss,List<List<Integer>> res)
    {
        if(arrIdx==n)
        {
          if(res.contains(new ArrayList<Integer>(ss))==false)
            res.add(new ArrayList<>(ss));
        }  
        else
        {
          //Include element
          ss.add(arr[arrIdx]);
          generateUniqueSubsets(arr,n,arrIdx+1,ss,res);
          //Exclude Element
          ss.remove(ss.size()-1);
          generateUniqueSubsets(arr,n,arrIdx+1,ss,res); 
        }
    }
}


//Optimal Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> res = new ArrayList<>();
        List<Integer>subset=new ArrayList<>();
       
	generateUniqueSubsets(arr,arr.length,0,subset,res);

      return res;   
    }

    public void generateUniqueSubsets(int[] arr,int n,int arrIdx,List<Integer>ss,List<List<Integer>> res)
    {
       if(arrIdx==n)
          res.add(new ArrayList<>(ss));
       else
       {
           //Include element
           ss.add(arr[arrIdx]);
           generateUniqueSubsets(arr,n,arrIdx+1,ss,res);
           //Exclude Element
           while(arrIdx+1<n && arr[arrIdx]==arr[arrIdx+1])
             arrIdx++;

           ss.remove(ss.size()-1);
           generateUniqueSubsets(arr,n,arrIdx+1,ss,res); 
       } 
    }
}
