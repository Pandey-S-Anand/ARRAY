/*
What if we dont sort the subset before including in the result ?

Ex: arr[]= [4,4,4,1,4]

[]

[4]

[4]      //Not Included Because Already Present
[4, 4]

[4].    //Not Included Because Already Present
[4, 4]  //Not Included Because Already Present
[4, 4, 4]

[1]
[4, 1]
[4, 4, 1]
[4, 4, 4 ,1]

[4]         //Not Included Because Already Present
[4 , 4]    //Not Included Because Already Present
[4, 4, 4]  //Not Included Because Already Present
[4, 4, 4, 4]
[1, 4]
[4, 1, 4]
[4, 4, 1, 4]
[4, 4, 4, 1, 4]

(On observation : [1, 4] , [4, 1, 4] and  [4, 4, 1, 4] are duplicate subsets)
*/

//Iterative Approach

// Method 1

//Intuitive Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());

        for (int i = 0; i < arr.length; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> subset = new ArrayList<>(subsets.get(j));
                subset.add(arr[i]);
                Collections.sort(subset);
                if (!subsets.contains(subset)) {
                    subsets.add(subset);
                }
            }
        }

        return subsets;
    }
}


//Optimal Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());
        // If array is sorted,the generated subsets will also be in sorted order
        Arrays.sort(arr);
        for (int i = 0; i < arr.length; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> subset = new ArrayList<>(subsets.get(j));
                subset.add(arr[i]);
                if (!subsets.contains(subset)) {
                    subsets.add(subset);
                }
            }
        }

        return subsets;
    }
}



//Method 2 (Using Bit Manipulation)

//Intuitive Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        int totalSubsets = 1 << arr.length;

        for (int num = 0; num < totalSubsets; num++) {
            List<Integer> subset = new ArrayList<>();
            String binaryWithoutLeadingZeroes = Integer.toBinaryString(num);
            int length = binaryWithoutLeadingZeroes.length();

            for (int i = length - 1; i >= 0; i--) {
                if (binaryWithoutLeadingZeroes.charAt(i) == '1') {
                    subset.add(arr[length - i - 1]);
                }
            }

            Collections.sort(subset);

            if (!subsets.contains(subset)) {
                subsets.add(subset);
            }
        }

        return subsets;
    }
}



//Optimal Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        int totalSubsets = 1 << arr.length;

        Arrays.sort(arr);

        for (int num = 0; num < totalSubsets; num++) {
            List<Integer> subset = new ArrayList<>();
            String binaryWithoutLeadingZeroes = Integer.toBinaryString(num);
            int length = binaryWithoutLeadingZeroes.length();

            for (int i = length - 1; i >= 0; i--) {
                if (binaryWithoutLeadingZeroes.charAt(i) == '1') {
                    subset.add(arr[length - i - 1]);
                }
            }

            if (!subsets.contains(subset)) {
                subsets.add(subset);
            }
        }

        return subsets;
    }
}


//Recursive Approach

//Bruteforce Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        generateUniquesubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            List<Integer> newSubset = new ArrayList<>(subset);
            Collections.sort(newSubset);
            if (!subsets.contains(newSubset)) {
                subsets.add(newSubset);
            }
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, subsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, subsets);
        }
    }
}


//Improved Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Set<List<Integer>> uniqueSubsets = new HashSet<>();
        generateUniquesubset(arr, 0, new ArrayList<>(), uniqueSubsets);
        return new ArrayList<>(uniqueSubsets);
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, Set<List<Integer>> uniqueSubsets) {
        if (index == arr.length) {
            List<Integer> newSubset = new ArrayList<>(subset);
            Collections.sort(newSubset);
            uniqueSubsets.add(newSubset);
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, uniqueSubsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, uniqueSubsets);
        }
    }
}


//Good Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        Arrays.sort(arr);
        generateUniquesubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            if (!subsets.contains(subset)) {
                subsets.add(new ArrayList<>(subset));
            }
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, subsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, subsets);
        }
    }
}


//Better Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        Set<List<Integer>> uniqueSubsets = new HashSet<>();
        generateUniqueSubset(arr, 0, new ArrayList<>(), uniqueSubsets);
        return new ArrayList<>(uniqueSubsets);
    }

    private void generateUniqueSubset(int[] arr, int index, List<Integer> subset, Set<List<Integer>> uniqueSubsets) {
        if (index == arr.length) {
            uniqueSubsets.add(new ArrayList<>(subset));
        } else {
            subset.add(arr[index]);
            generateUniqueSubset(arr, index + 1, subset, uniqueSubsets);
            subset.remove(subset.size() - 1);
            generateUniqueSubset(arr, index + 1, subset, uniqueSubsets);
        }
    }
}

/*
Given array= [1, 2, 3, 2]

Recursive Tree (No Duplicate Skipping):

[]
├── [1] // Include 1
│   ├── [1, 2] // Include 2
│   │   ├── [1, 2, 3] // Include 3
│   │   │   ├── [1, 2, 3, 2] // Include 2
│   │   │   └── [1, 2, 3] // Exclude 2
│   │   └── [1, 2] // Exclude 3
│   │       ├── [1, 2, 2] // Include 2
│   │       └── [1, 2] // Exclude 2
│   └── [1] // Exclude 2
│       ├── [1, 3] // Include 3
│       │   ├── [1, 3, 2] // Include 2
│       │   └── [1, 3] // Exclude 2
│       └── [1] // Exclude 3
│           ├── [1, 2] // Include 2
│           │   ├── [1, 2, 2] // Include 2
│           │   └── [1, 2] // Exclude 2
│           └── [1] // Exclude 2
└── [] // Exclude 1
    ├── [2] // Include 2
    │   ├── [2, 3] // Include 3
    │   │   ├── [2, 3, 2] // Include 2
    │   │   └── [2, 3] // Exclude 2
    │   └── [2] // Exclude 3
    │       ├── [2, 2] // Include 2
    │       └── [2] // Exclude 2
    └── [] // Exclude 2
        ├── [3] // Include 3
        │   ├── [3, 2] // Include 2
        │   └── [3] // Exclude 2
        └── [] // Exclude 3
            ├── [2] // Include 2
            │   ├── [2, 2] // Include 2
            │   └── [2] // Exclude 2
            └── [] // Exclude 2

All Subsets : [[1,2,3,2],[1,2,3],[1,2,2],[1,2],[1,3,2],[1,3],[1,2],[1],[2,3,2],[2,3],[2,2],[2],[3,2],[3],[2],[]]
Duplicate subsets : [1, 3, 2] ,[1, 2] , [3, 2] and [2]
*/


/*
Given Array : [1, 2, 3, 2]
sorted array : {1, 2, 2, 3}

[]
|(index = 0)
├── [1] // Include 1. 
|   | (index=1)
│   ├── [1, 2] // Include 2  
|   |   | (index=2)
│   │   ├── [1, 2, 2] 
|   |   |   |(index=3)
│   │   │   ├── [1, 2, 2, 3] // Include 3 
|   |   |   |   //Nothing to skip
│   │   │   └── [1, 2, 2] // Exclude 3
|   |   |   //Nothing to skip
│   │   └── [1, 2] // Exclude 2. 
|   |       |(index=3)
│   │       ├── [1, 2, 3] // Include 3
|   |       |   //Nothing to skip
│   │       └── [1, 2] // Exclude 3
|   |
|   |   //Skip 2
│   └── [1] // Exclude 2
|       |(index=3)
│       ├── [1, 3] // Include 3  
|       |  //Nothing to skip
│       └── [1] // Exclude 3
|
|   //Nothing to skip
└── [] // Exclude 1
    |(index = 1)
    ├── [2] // Include 2
    |   |(index=2)
    │   ├── [2, 2] // Include 2
    |   |   |(index=3)
    │   │   ├── [2, 2, 3] // Include 3
    |   |   | //Nothing to skip
    │   │   └── [2, 2] // Exclude 3
    |   |   //Nothing to skip
    │   └── [2] // Exclude 2
    |       |(index =3)
    │       ├── [2, 3] // Include 3
    |       | //Nothing to skip
    │       └── [2] // Exclude 3
    |
    |   //Skip 2
    └── [] // Exclude 2
        |(index=3)
        ├── [3] // Include 3
        │ //Nothing to skip   
        └── [] // Exclude 3


 All subsets : [[1,2,2,3], [1,2,2], [1,2,3], [1,2], [1,3], [1], [2,2,3], [2,2], [2,3], [2], [3], []]
*/

//Optimal Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> subsets = new ArrayList<>();
        generateUniqueSubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniqueSubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            subsets.add(new ArrayList<>(subset));
        } else {
            subset.add(arr[index]);
            generateUniqueSubset(arr, index + 1, subset, subsets);
            while (index + 1 < arr.length && arr[index] == arr[index + 1]) {
                index++;
            }
            subset.remove(subset.size() - 1);
            generateUniqueSubset(arr, index + 1, subset, subsets);
        }
    }
}
