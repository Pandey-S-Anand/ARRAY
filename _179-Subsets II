/*
What if we dont sort the subset before including in the result ?

Ex: arr[]= [4,4,4,1,4]

[]

[4]

[4]      //Not Included Because Already Present
[4, 4]

[4].    //Not Included Because Already Present
[4, 4]  //Not Included Because Already Present
[4, 4, 4]

[1]
[4, 1]
[4, 4, 1]
[4, 4, 4 ,1]

[4]         //Not Included Because Already Present
[4 , 4]    //Not Included Because Already Present
[4, 4, 4]  //Not Included Because Already Present
[4, 4, 4, 4]
[1, 4]
[4, 1, 4]
[4, 4, 1, 4]
[4, 4, 4, 1, 4]

(On observation : [1, 4] , [4, 1, 4] and  [4, 4, 1, 4] are duplicate subsets)
*/

//Iterative Approach

// Method 1

//Intuitive Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());

        for (int i = 0; i < arr.length; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> subset = new ArrayList<>(subsets.get(j));
                subset.add(arr[i]);
                Collections.sort(subset);
                if (!subsets.contains(subset)) {
                    subsets.add(subset);
                }
            }
        }

        return subsets;
    }
}


//Optimal Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());
        // If array is sorted,the generated subsets will also be in sorted order
        Arrays.sort(arr);
        for (int i = 0; i < arr.length; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> subset = new ArrayList<>(subsets.get(j));
                subset.add(arr[i]);
                if (!subsets.contains(subset)) {
                    subsets.add(subset);
                }
            }
        }

        return subsets;
    }
}



//Method 2 (Using Bit Manipulation)

//Intuitive Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        int totalSubsets = 1 << arr.length;

        for (int num = 0; num < totalSubsets; num++) {
            List<Integer> subset = new ArrayList<>();
            String binaryWithoutLeadingZeroes = Integer.toBinaryString(num);
            int length = binaryWithoutLeadingZeroes.length();

            for (int i = length - 1; i >= 0; i--) {
                if (binaryWithoutLeadingZeroes.charAt(i) == '1') {
                    subset.add(arr[length - i - 1]);
                }
            }

            Collections.sort(subset);

            if (!subsets.contains(subset)) {
                subsets.add(subset);
            }
        }

        return subsets;
    }
}



//Optimal Implementation

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        int totalSubsets = 1 << arr.length;

        Arrays.sort(arr);

        for (int num = 0; num < totalSubsets; num++) {
            List<Integer> subset = new ArrayList<>();
            String binaryWithoutLeadingZeroes = Integer.toBinaryString(num);
            int length = binaryWithoutLeadingZeroes.length();

            for (int i = length - 1; i >= 0; i--) {
                if (binaryWithoutLeadingZeroes.charAt(i) == '1') {
                    subset.add(arr[length - i - 1]);
                }
            }

            if (!subsets.contains(subset)) {
                subsets.add(subset);
            }
        }

        return subsets;
    }
}


//Recursive Approach

//Bruteforce Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        generateUniquesubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            List<Integer> newSubset = new ArrayList<>(subset);
            Collections.sort(newSubset);
            if (!subsets.contains(newSubset)) {
                subsets.add(newSubset);
            }
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, subsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, subsets);
        }
    }
}


//Improved Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Set<List<Integer>> uniqueSubsets = new HashSet<>();
        generateUniquesubset(arr, 0, new ArrayList<>(), uniqueSubsets);
        return new ArrayList<>(uniqueSubsets);
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, Set<List<Integer>> uniqueSubsets) {
        if (index == arr.length) {
            List<Integer> newSubset = new ArrayList<>(subset);
            Collections.sort(newSubset);
            uniqueSubsets.add(newSubset);
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, uniqueSubsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, uniqueSubsets);
        }
    }
}


//Good Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        Arrays.sort(arr);
        generateUniquesubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniquesubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            if (!subsets.contains(subset)) {
                subsets.add(new ArrayList<>(subset));
            }
        } else {
            subset.add(arr[index]);
            generateUniquesubset(arr, index + 1, subset, subsets);
            subset.remove(subset.size() - 1);
            generateUniquesubset(arr, index + 1, subset, subsets);
        }
    }
}


//Better Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        Set<List<Integer>> uniqueSubsets = new HashSet<>();
        generateUniqueSubset(arr, 0, new ArrayList<>(), uniqueSubsets);
        return new ArrayList<>(uniqueSubsets);
    }

    private void generateUniqueSubset(int[] arr, int index, List<Integer> subset, Set<List<Integer>> uniqueSubsets) {
        if (index == arr.length) {
            uniqueSubsets.add(new ArrayList<>(subset));
        } else {
            subset.add(arr[index]);
            generateUniqueSubset(arr, index + 1, subset, uniqueSubsets);
            subset.remove(subset.size() - 1);
            generateUniqueSubset(arr, index + 1, subset, uniqueSubsets);
        }
    }
}


//Optimal Approach

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> subsets = new ArrayList<>();
        generateUniqueSubset(arr, 0, new ArrayList<>(), subsets);
        return subsets;
    }

    private void generateUniqueSubset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            subsets.add(new ArrayList<>(subset));
        } else {
            subset.add(arr[index]);
            generateUniqueSubset(arr, index + 1, subset, subsets);
            while (index + 1 < arr.length && arr[index] == arr[index + 1]) {
                index++;
            }
            subset.remove(subset.size() - 1);
            generateUniqueSubset(arr, index + 1, subset, subsets);
        }
    }
}
