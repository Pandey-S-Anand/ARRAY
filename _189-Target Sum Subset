//Bruteforce Approach

//Naive Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());

        for (int i = 0; i < n; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> currentSubset = new ArrayList<>(subsets.get(j));
                currentSubset.add(arr[i]);
                if (findSubsetSum(currentSubset) == targetSum) {
                    return true;
                }
                subsets.add(currentSubset);
            }
        }

        return false;
    }

    private static int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }
        return subsetSum;
    }
}


//Optimal Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        // Set to store the sums of all subsets found so far, starting with the empty subset sum of 0
        Set<Integer> subsetsSum = new HashSet<>();
        subsetsSum.add(0);

        for (int i = 0; i < n; i++) {
            Set<Integer> existingSubsetsSum = new HashSet<>(subsetsSum);
            for (int subsetSum : existingSubsetsSum) {
                int newSubsetSum = subsetSum + arr[i];

                if (newSubsetSum == targetSum) {
                    return true;
                }
                /*
                 * Add the new subset sum to the set if it is less than the target sum
                 * This helps keep track of all valid subset sums that could potentially match the target.
                 */

                if (newSubsetSum < targetSum) {
                    subsetsSum.add(newSubsetSum);
                }
            }
        }

        return false;
    }
}



//Improved Approach

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        int currentSubsetSum = 0;
        int totalSubsets = 1 << n; // x << y = x * 2^n

        for (int num = 0; num < totalSubsets; num++) {
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    currentSubsetSum += arr[i];

                    /*
                     * If current subset sum exceeds targetSum, no need to continue
                     * Since the array only contains positive elements, further additions will never give the desired target
                     */
                    if (currentSubsetSum > targetSum) {
                        break;
                    }
                }
            }

            if (currentSubsetSum == targetSum) {
                return true;
            }

            currentSubsetSum = 0;
        }

        return false;
    }
}



//Good Approach

//Method 1

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, arr.length - 1, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int targetSum) {
        /*
         * Base case: If we've exhauated the array (index < 0),
         * check if the target sum is zero. If it is, we have found a valid subset
         * that adds up to the target sum, so return 1 to count this subset.
         * Otherwise, return 0 to indicate no valid subset was found for this path.
         */

        if (index < 0) {
            return targetSum == 0 ? 1 : 0;
        }
        
         /*
         * If the current element is greater than the target sum, we cannot include it in the subset.
         * Including this element would reduce the target sum to a negative value, which is not achievable.
         * According to the problem constraints, both the array elements and the target
         * sum are positive.Therefore, once the target sum becomes negative, it cannot return to a
         * non-negative value, so this path can safely be ignored.
         * This check prevents unnecessary recursive calls, improving the efficiency of the algorithm.
         */
        int include = 0;
        if (targetSum >= arr[index]) {
            include = countSubsetsWithTargetSum(arr, index - 1, targetSum - arr[index]) % MOD;
        }

        int exclude = countSubsetsWithTargetSum(arr, index - 1, targetSum) % MOD;

        return (include + exclude) % MOD;
    }
}


//Method 2

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, arr.length - 1, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        for (int i = index; i >= 0; i--) {
            if (targetSum >= arr[i] && hasSubsetWithTargetSum(arr, i - 1, targetSum - arr[i])) {
                return true;
            }
        }

        return false;
    }
}


//Better Approach

//Method 1

class Solution {
    private static int[][] cache;

    static Boolean isSubsetSum(int arr[], int targetSum) {
        cache = new int[arr.length][targetSum + 1];
        intializeCache();
        return hasSubsetWithTargetSum(arr, arr.length - 1, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (index < 0) {
            return false;
        }

        if (cache[index][targetSum] != -1) {
            return cache[index][targetSum] == 1;
        }

        boolean include = false;

        if (targetSum >= arr[index]) {
            include = hasSubsetWithTargetSum(arr, index - 1, targetSum - arr[index]);
        }

        boolean exclude = hasSubsetWithTargetSum(arr, index - 1, targetSum);

        cache[index][targetSum] = (include || exclude) ? 1 : 0;

        return cache[index][targetSum] == 1;
    }

    private static void intializeCache() {
        for (int i = 0; i < cache.length; i++) {
            Arrays.fill(cache[i], -1);
        }
    }
}


//Method 2

class Solution {
    private static int[][] cache;

    static Boolean isSubsetSum(int arr[], int targetSum) {
        cache = new int[arr.length][targetSum + 1];
        intializeCache();
        return hasSubsetWithTargetSum(arr, arr.length - 1, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (cache[index][targetSum] != -1) {
            return cache[index][targetSum] == 1;
        }

        for (int i = index; i >= 0; i--) {
            if (targetSum >= arr[i] && hasSubsetWithTargetSum(arr, i - 1, targetSum - arr[i])) {
                cache[index][targetSum] = 1;
                return cache[index][targetSum] == 1;
            }
        }

        cache[index][targetSum] = 0;
        return cache[index][targetSum] == 1;
    }

    private static void intializeCache() {
        for (int i = 0; i < cache.length; i++) {
            Arrays.fill(cache[i], -1);
        }
    }
}


//Optimal Approach

//Naive Implementation

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        // dp[i][j] represents whether it is possible to achieve a target sum of j using the subarray [0..i-1]
        boolean[][] dp=new boolean[arr.length+1][targetSum + 1];
        
        dp[0][0]=true;
        
        for(int sum=1;sum<=targetSum;sum++){
            dp[0][sum]=false;
        }
        
        for(int index=1;index<=arr.length;index++){
            dp[index][0]=true;
        }
        
        for(int index=1;index<=arr.length;index++){
            for(int sum=1;sum<=targetSum;sum++){
               boolean exclude=dp[index-1][sum];
               
               boolean include=false;
               if(sum>=arr[index-1]){
                  include=dp[index-1][sum-arr[index-1]];
               }    
               dp[index][sum]= include || exclude;
            }
            
            if(dp[index][targetSum]){
                return true;
            }
        }
        
        return dp[arr.length][targetSum];
    }
}


//Optimal Implementation 

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        boolean[][] dp = new boolean[arr.length + 1][targetSum + 1];

        for (int index = 0; index <= arr.length; index++) {
            dp[index][0] = true;
        }

        for (int index = 1; index <= arr.length; index++) {
            for (int sum = 1; sum <= targetSum; sum++) {
                boolean exclude = dp[index - 1][sum];

                boolean include = false;
                if (sum >= arr[index - 1]) {
                    include = dp[index - 1][sum - arr[index - 1]];
                }
                dp[index][sum] = include || exclude;
            }

            if (dp[index][targetSum]) {
                return true;
            }
        }

        return dp[arr.length][targetSum];
    }
}


//Aliter (Space optimized)
/*
Intuition : Only current('i') and previous row('i-1') of martrix (dp[][]) is being used so instead of 'dp[][]'
we can create 2 1D arrays (boolean[] previousRow and boolean[] currentRow) representing previous and current row 
*/

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        boolean[] currentRow = new boolean[targetSum + 1];
        boolean[] previousRow = new boolean[targetSum + 1];

        previousRow[0] = true;

        for (int index = 1; index <= arr.length; index++) {
            currentRow[0] = true;
            for (int sum = 1; sum <= targetSum; sum++) {
                boolean exclude = previousRow[sum];

                boolean include = false;
                if (sum >= arr[index - 1]) {
                    include = previousRow[sum - arr[index - 1]];
                }
                currentRow[sum] = include || exclude;
            }

            if (currentRow[targetSum]) {
                return true;
            }

            boolean[] temp = currentRow;
            currentRow = previousRow;
            previousRow = temp;
        }

        return previousRow[targetSum];
    }
}

//Aliter (further space optimised)

class Solution {
    static Boolean isSubsetSum(int arr[], int targetSum) {
        boolean[] dp=new boolean[targetSum+1];
        
        for(int index=1;index<=arr.length;index++){
            dp[0]=true;
            for(int sum=targetSum;sum>=1;sum--){
               boolean exclude=dp[sum];
               
               boolean include=false;
               if(sum>=arr[index-1]){
                  include=dp[sum-arr[index-1]];
               }    
               dp[sum]= include || exclude;
            }
            
            if(dp[targetSum]){
                return true;
            }
        }
        
        return dp[targetSum];
    }
}
