//Bruteforce Approach

/*
Important Testcases:
Ex: 1

arr = {0 ,0, 0, 0}
targetSum=0

Output  : 16

Ex: 2

arr= {0, 0, 1, 0, 1}
targetSum=0

Output  : 8
*/

class Solution {
    private static final int MOD = 1000000007;

    public int perfectSum(int arr[], int n, int targetSum) {
        List<Integer> subsetSums = new ArrayList<>();
        subsetSums.add(0); // Start with the empty subset sum (i.e 0)
        int targetSumSubsetCount = targetSum == 0 ? 1 : 0;

        for (int num : arr) {
            int currentSize = subsetSums.size();
            for (int i = 0; i < currentSize; i++) {
                int newSubsetSum = num + subsetSums.get(i);

                if (newSubsetSum == targetSum) {
                    targetSumSubsetCount = (targetSumSubsetCount + 1) % MOD;
                }

                if (newSubsetSum <= targetSum) {
                    subsetSums.add(newSubsetSum);
                }
            }
        }

        return targetSumSubsetCount;
    }
}


//Improved Approach

class Solution {
    private static final int MOD = 1000000007;

    public int perfectSum(int arr[], int n, int targetSum) {
        int targetSumSubsetCount = 0, newSubsetSum = 0, totalSubsets = 1 << n;

        for (int num = 0; num < totalSubsets; num++) {
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    newSubsetSum += arr[i];

                    if (newSubsetSum > targetSum) {
                        break;
                    }
                }
            }

            if (newSubsetSum == targetSum) {
                targetSumSubsetCount = (targetSumSubsetCount + 1) % MOD;
            }

            newSubsetSum = 0;
        }

        return targetSumSubsetCount;
    }
}


//Good Approach

class Solution {
    private static final int MOD = 1000000007;

    public static int perfectSum(int arr[], int n, int targetSum) {
        return countSubsetsWithTargetSum(arr, n - 1, targetSum);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index, int targetSum) {
        /*
         * Base case: If we've exhauated the array (index < 0),
         * check if the target sum is zero. If it is, we have found a valid subset
         * that adds up to the target sum, so return 1 to count this subset.
         * Otherwise, return 0 to indicate no valid subset was found for this path.
         */

        if (index < 0) {
            return targetSum == 0 ? 1 : 0;
        }

        /*
         * If the current element is greater than the target sum, we cannot include it in the subset.
         * Including this element would reduce the target sum to a negative value, which is not achievable.
         * According to the problem constraints, both the array elements and the target
         * sum are non-negative.Therefore, once the target sum becomes negative, it cannot return to a
         * non-negative value, so this path can safely be ignored.
         */

        int include = 0;
        if (targetSum >= arr[index]) {
            include = countSubsetsWithTargetSum(arr, index - 1, targetSum - arr[index]) % MOD;
        }

        int exclude = countSubsetsWithTargetSum(arr, index - 1, targetSum) % MOD;

        return (include + exclude) % MOD;
    }
}


//Aliter

class Solution {
    private static final int MOD = 1000000007;
    private static int targetSumSubsetsCount;

    public static int perfectSum(int arr[], int n, int targetSum) {
        targetSumSubsetsCount = 0;
        countSubsetsWithTargetSum(arr, n - 1, 0, targetSum);
        return targetSumSubsetsCount;
    }

    private static void countSubsetsWithTargetSum(int[] arr, int index, int currentSubsetSum, int targetSum) {
        if (currentSubsetSum == targetSum) {
            targetSumSubsetsCount = (targetSumSubsetsCount + 1) % MOD;
        }

        for (int i = index; i >= 0; i--) {
            if (currentSubsetSum + arr[i] <= targetSum) {
                countSubsetsWithTargetSum(arr, i - 1, currentSubsetSum + arr[i], targetSum);
            }
        }
    }
}


//Better Approach

class Solution {
    private static final int MOD = 1000000007;
    private static int[][] cache;

    public static int perfectSum(int arr[], int n, int targetSum) {
        cache = new int[n][targetSum + 1];
        intializeCache();
        return countSubsetsWithTargetSum(arr, n - 1, targetSum);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index, int targetSum) {
        if (index < 0) {
            return targetSum == 0 ? 1 : 0;
        }

        if (cache[index][targetSum] != -1) {
            return cache[index][targetSum];
        }
        
        int include = 0;
        if (targetSum >= arr[index]) {
            include = countSubsetsWithTargetSum(arr, index - 1, targetSum - arr[index]) % MOD;
        }

        int exclude = countSubsetsWithTargetSum(arr, index - 1, targetSum) % MOD;

        return cache[index][targetSum] = (include + exclude) % MOD;
    }

    private static void intializeCache() {
        for (int i = 0; i < cache.length; i++) {
            Arrays.fill(cache[i], -1);
        }
    }
}


//Optimal Approach

//Naive Implementation

class Solution {
    private static final int MOD = 1000000007;

    public static int perfectSum(int arr[], int n, int targetSum) {
        // dp[i][j] indicates the count of subsets of the subarray arr[0..i-1] that sum to target 'j'
        int[][] dp = new int[n + 1][targetSum + 1];

        // There is one way to achieve a sum of 0 using an empty array, and that way is by selecting the empty subset.
        dp[0][0] = 1;

        // If the array is empty , we cannot form any positive target sum
        for (int sum = 1; sum <= targetSum; sum++) {
            dp[0][sum] = 0;
        }

        for (int index = 1; index <= n; index++) {
            for (int sum = 0; sum <= targetSum; sum++) {
                int include = 0;
                if (sum >= arr[index - 1]) {
                    include = dp[index - 1][sum - arr[index - 1]] % MOD;
                }
                int exclude = dp[index - 1][sum] % MOD;
                dp[index][sum] = (include + exclude) % MOD;
            }
        }

        return dp[n][targetSum];
    }
}


//Optimal Implementation 

class Solution {
    private static final int MOD = 1000000007;

    public static int perfectSum(int arr[], int n, int targetSum) {
        int[][] dp = new int[n + 1][targetSum + 1];

        dp[0][0] = 1;

        for (int index = 1; index <= n; index++) {
            for (int sum = 0; sum <= targetSum; sum++) {
                int include = 0;
                if (sum >= arr[index - 1]) {
                    include = dp[index - 1][sum - arr[index - 1]] % MOD;
                }
                int exclude = dp[index - 1][sum] % MOD;
                dp[index][sum] = (include + exclude) % MOD;
            }
        }

        return dp[n][targetSum];
    }
}


//Aliter (Space optimised implementation)

class Solution {
    private static final int MOD = 1000000007;

    public static int perfectSum(int arr[], int n, int targetSum) {
        int[] previousRow = new int[targetSum + 1];
        int[] currentRow = new int[targetSum + 1];

        previousRow[0] = 1;

        for (int index = 1; index <= n; index++) {
            for (int sum = 0; sum <= targetSum; sum++) {
                int include = 0;
                if (sum >= arr[index - 1]) {
                    include = previousRow[sum - arr[index - 1]] % MOD;
                }
                int exclude = previousRow[sum] % MOD;
                currentRow[sum] = (include + exclude) % MOD;
            }
            int[] temp = currentRow;
            currentRow = previousRow;
            previousRow = temp;
        }

        return previousRow[targetSum];
    }
}

//Aliter (Further space optimised implementation)

class Solution {
    private static final int MOD = 1000000007;

    public static int perfectSum(int arr[], int n, int targetSum) {
        int[] dp = new int[targetSum + 1];

        dp[0] = 1;

        for (int index = 1; index <= n; index++) {
            for (int sum = targetSum; sum >= 0; sum--) {
                int include = 0;
                if (sum >= arr[index - 1]) {
                    include = dp[sum - arr[index - 1]] % MOD;
                }
                int exclude = dp[sum] % MOD;
                dp[sum] = (include + exclude) % MOD;
            }
        }

        return dp[targetSum];
    }
}
