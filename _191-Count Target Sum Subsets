//Bruteforce Approach

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        int targetSumSubsetCount = 0;
        List<Integer> subsetSums = new ArrayList<>();
        subsetSums.add(0); // Start with the empty subset sum (i.e 0)

        for (int num : arr) {
            int currentSize = subsetSums.size();
            for (int i = 0; i < currentSize; i++) {
                int newSubsetSum = num + subsetSums.get(i);

                if (newSubsetSum == targetSum) {
                    targetSumSubsetCount = (targetSumSubsetCount + 1) % MOD;
                }

                if (newSubsetSum <= targetSum) {
                    subsetSums.add(newSubsetSum);
                }
            }
        }

        return targetSumSubsetCount;
    }
}


//Improved Approach

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        int targetSumSubsetCount = 0, newSubsetSum = 0, totalSubsets = 1 << arr.length; // x << y = x * 2^n

        for (int num = 0; num < totalSubsets; num++) {
            for (int i = 0; i < arr.length; i++) {
                if ((num & (1 << i)) != 0) {
                    newSubsetSum += arr[i];

                    if (newSubsetSum > targetSum) {
                        break;
                    }
                }
            }

            if (newSubsetSum == targetSum) {
                targetSumSubsetCount = (targetSumSubsetCount + 1) % MOD;
            }

            newSubsetSum = 0;
        }

        return targetSumSubsetCount;
    }
}


//Good Approach

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        return countSubsetsWithTargetSum(arr, 0, targetSum);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index, int targetSum) {
        if (targetSum == 0) {
            return 1;
        }

        if (index == arr.length || targetSum < 0) {
            return 0;
        }

        int include = countSubsetsWithTargetSum(arr, index + 1, targetSum - arr[index]) % MOD;
        int exclude = countSubsetsWithTargetSum(arr, index + 1, targetSum) % MOD;

        return (include + exclude) % MOD;
    }
}


//Aliter

public class Solution {
    private static final int MOD = 1000000007;
    private static int targetSumSubsetsCount = 0;

    public static int findWays(int arr[], int targetSum) {
        generateSubsetsSum(arr, 0, 0, targetSum);
        return targetSumSubsetsCount;
    }

    private static void generateSubsetsSum(int[] arr, int index, int currentSubsetSum, int targetSum) {
        if (currentSubsetSum == targetSum) {
            targetSumSubsetsCount = (targetSumSubsetsCount + 1) % MOD;
        }

        if (currentSubsetSum > targetSum) {
            return;
        }

        for (int i = index; i < arr.length; i++) {
            generateSubsetsSum(arr, i + 1, currentSubsetSum + arr[i], targetSum);
        }
    }
}


//Better Approach

public class Solution {
    private static int[][] memo;
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        memo = new int[arr.length][targetSum + 1];
        intializeMemo();
        return countSubsetsWithTargetSum(arr, 0, targetSum);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index, int targetSum) {
        if (targetSum == 0) {
            return 1;
        }

        if (index == arr.length || targetSum < 0) {
            return 0;
        }

        if (memo[index][targetSum] != -1) {
            return memo[index][targetSum];
        }

        int include = countSubsetsWithTargetSum(arr, index + 1, targetSum - arr[index]) % MOD;
        int exclude = countSubsetsWithTargetSum(arr, index + 1, targetSum) % MOD;

        return memo[index][targetSum] = (include + exclude) % MOD;
    }

    private static void intializeMemo() {
        for (int i = 0; i < memo.length; i++) {
            Arrays.fill(memo[i], -1);
        }
    }
}


//Optimal Approach

//Naive Implementation

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        // dp[i][j] indicates the count of subsets of the subarray arr[0..i-1] that sum to target 'j'
        int[][] dp = new int[arr.length + 1][targetSum + 1];
        /*
         * If the target sum is 0, we can always form that sum with an empty subset
         * because every array contains an empty subset that sums to 0.
         */
        for (int i = 0; i <= arr.length; i++) {
            dp[i][0] = 1;
        }

        // If the array is empty , we cannot form any positive target sum
        for (int i = 1; i <= targetSum; i++) {
            dp[0][i] = 0;
        }

        for (int i = 1; i <= arr.length; i++) {
            for (int j = 1; j <= targetSum; j++) {
                if (j < arr[i - 1]) {
                    /*
                     * If the current element is greater than the target sum We cannot include this
                     * element because if we include the current element (arr[i-1]) the 
                     * current target (j) will become negative hence not acheiveable
                     * because array contains only positive elements once the target becomes
                     * negative it will stay negative.
                     */
                    dp[i][j] = dp[i - 1][j];
                } else {
                    /*
                     * We can either exclude the current element or include it
                     * Count subsets that do not include the current element
                     * plus count subsets that include the current element
                     */
                    dp[i][j] = (dp[i - 1][j - arr[i - 1]] + dp[i - 1][j]) % MOD;
                }
            }
        }

        return dp[arr.length][targetSum]; // Return count of subsets that can form the target sum using all the elements
    }
}


//Optimal Implementation 

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        int[][] dp = new int[arr.length + 1][targetSum + 1];

        for (int i = 0; i <= arr.length; i++) {
            dp[i][0] = 1;
        }

        for (int i = 1; i <= arr.length; i++) {
            for (int j = 1; j <= targetSum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= arr[i - 1]) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - arr[i - 1]]) % MOD;
                }
            }
        }

        return dp[arr.length][targetSum];
    }
}


//Aliter (Space optimised implementation)


public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int targetSum) {
        int[] previousRow = new int[targetSum + 1];
        int[] currentRow = new int[targetSum + 1];

        previousRow[0] = 1;

        for (int i = 1; i <= arr.length; i++) {
            currentRow[0] = 1;
            for (int j = 1; j <= targetSum; j++) {
                currentRow[j] = previousRow[j];
                if (j >= arr[i - 1]) {
                    currentRow[j] = (currentRow[j] + previousRow[j - arr[i - 1]]) % MOD;
                }
            }

            int[] temp = previousRow;
            previousRow = currentRow;
            currentRow = temp;
        }

        return previousRow[targetSum];
    }
}


/*
  If you want to print all the target sum subsets or count target sum subsets the 
  following implementations wont give correct output if the given array contains '0' as element
  i.e it will only work if the array contains positive elements.

  Ex:

  For Input: 
  2 1
  1 0

  Your Code's output is: 
  1

  It's Correct output is: 
  2


//Implementation 1

class Solution {
    private static final int MOD = 1000000007;

    public int perfectSum(int[] arr, int n, int targetSum) {
        return generateSubsetsSum(arr, 0, 0,  targetSum);
    }

    private int generateSubsetsSum(int[] arr, int index, int currentSubsetSum, int targetSum) {
        if (currentSubsetSum == targetSum) {
           return 1;
        }

        if (currentSubsetSum > targetSum) {
            return 0;
        }
        
        int targetSumSubsetsCount=0;
        for (int i = index; i < arr.length; i++) {
            targetSumSubsetsCount = (targetSumSubsetsCount + generateSubsetsSum(arr, i + 1, currentSubsetSum + arr[i], targetSum))%MOD;
        }
        
        return targetSumSubsetsCount;
    }
}


//Implementation 2

public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int k) {
      return countSubsetsWithTargetSum(arr,0,k);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index,int targetSum) {
        if (targetSum == 0) {
            return 1;
        }

        if (index == arr.length || targetSum < 0) {
            return 0;
        }

        int includeCurrent = countSubsetsWithTargetSum(arr, index + 1, targetSum - arr[index]);
        int excludeCurrent = countSubsetsWithTargetSum(arr, index + 1, targetSum);

        return (includeCurrent + excludeCurrent) % MOD;
    }
}


//Implementation 3


public class Solution {
    private static final int MOD = 1000000007;

    public static int findWays(int arr[], int k) {
      return countSubsetsWithTargetSum(arr,0,k);
    }

    private static int countSubsetsWithTargetSum(int[] arr, int index,int targetSum) {
        if (targetSum == 0) {
            return 1;
        }

        if (targetSum < 0) {
            return 0;
        }
        
        int targetSumSubsetCount = 0;
        for (int i = index; i < arr.length; i++) {
          targetSumSubsetCount=(targetSumSubsetCount + countSubsetsWithTargetSum(arr, i + 1,targetSum - arr[i]))%MOD;
        }

        return targetSumSubsetCount;
    }
}

*/
