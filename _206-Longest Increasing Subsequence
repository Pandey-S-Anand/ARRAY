//Bruteforce Approach

class Solution {
    public int lengthOfLIS(int[] arr) {
        return lengthOfLIS(arr, 0, -1);
    }

    private int lengthOfLIS(int[] arr, int index, int lastIncludedIdx) {
        if (index == arr.length) {
            return 0;
        }

        int include = 0;
        if (lastIncludedIdx == -1 || arr[lastIncludedIdx] < arr[index]) {
            include = 1 + lengthOfLIS(arr, index + 1, index);
        }

        int exclude = lengthOfLIS(arr, index + 1, lastIncludedIdx);

        return Math.max(include, exclude);
    }
}


//Better Approach

class Solution {
    private int[][] memo;

    public int lengthOfLIS(int[] arr) {
        int[][] dp = new int[arr.length][arr.length + 1];
        memo = new int[arr.length][arr.length + 1];
        intializeMemo();
        return lengthOfLIS(arr, 0, -1);
    }

    private int lengthOfLIS(int[] arr, int index, int lastIncludedIdx) {
        if (index == arr.length) {
            return 0;
        }

        if (memo[index][lastIncludedIdx + 1] != -1) {
            return memo[index][lastIncludedIdx + 1];
        }

        int include = 0;
        if (lastIncludedIdx == -1 || arr[lastIncludedIdx] < arr[index]) {
            include = 1 + lengthOfLIS(arr, index + 1, index);
        }

        int exclude = lengthOfLIS(arr, index + 1, lastIncludedIdx);

        return memo[index][lastIncludedIdx + 1] = Math.max(include, exclude);
    }

    private void intializeMemo() {
        for (int i = 0; i < memo.length; i++) {
            Arrays.fill(memo[i], -1);
        }
    }
}


//Optimal Approach

/*
   Approach:
   
   Subsequence Ending at Each Index:
   Every increasing subsequence in the array must end at some index `i`. 
   So, we focus on calculating the length of the longest increasing subsequence (LIS) that ends at each index `i`.
   Once we know the LIS length for each ending index, the longest subsequence in the array 
   will be the maximum length among these values.

   Finding Potential LIS Candidates:
   For each element `arr[i]`, we look at all previous elements `arr[j]` (where `j < i`).
   If `arr[i]` is greater than `arr[j]`, then `arr[i]` can extend the increasing subsequence that ends at `arr[j]`.

   Updating the LIS Length for Each `i`:
   - For each valid candidate `arr[j]`, we retrieve the LIS ending at `j` (stored in `dp[j]`).
   - Among all such candidates, the longest subsequence ending at `j` provides the longest possible subsequence that `i` can extend.
   - Finally, we add 1 to this length to include the current element `arr[i]`, which gives us the LIS length ending at `i`.

   Final Step:
   After calculating the LIS ending at each index, the overall longest increasing subsequence in the array
   is simply the maximum value in the `dp` array.
*/


class Solution {
    public int lengthOfLIS(int[] arr) {
       // dp[i] = length of longest increasing subsequence ending at index i
       int[] dp = new int[arr.length];

       for (int i = 0; i < arr.length; i++) {
           int maxLISLengthBeforeIndexI = 0;
           for (int j = 0; j < i; j++) {
               if (arr[i] > arr[j]) {
                   maxLISLengthBeforeIndexI = Math.max(maxLISLengthBeforeIndexI, dp[j]);
               }
           }
           dp[i] = maxLISLengthBeforeIndexI + 1;
       }
        
       int overallMaxLISLength = 0;
       for (int i = 0; i < arr.length; i++) {
           overallMaxLISLength = Math.max(dp[i], overallMaxLISLength);
       }

       return overallMaxLISLength;
    }
}
