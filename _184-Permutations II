//Bruteforce Approach

class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
      List<List<Integer>>res=new ArrayList<>();
      HashSet<List<Integer>>hs=new HashSet<>();
      List<Integer>arr=new ArrayList<>();

      for(int val:nums)
        arr.add(val);

      findAllPermutation(arr, 0, (arr.size()-1),hs);
      
      res.addAll(hs);

     return res;
    }

    private void findAllPermutation(List<Integer>arr, int start, int end,HashSet<List<Integer>>hs)
    {
        if (start == end)
          hs.add(new ArrayList<>(arr));
        else 
        {
          for (int i = start; i <= end; i++)
          {
            swap(arr, start, i);
            findAllPermutation(arr, start + 1, end,hs);
            swap(arr, start, i);
          }
        }
    }

    public void swap(List<Integer>arr, int i, int j)
    {
        int temp = arr.get(i);
        arr.set(i,arr.get(j));
        arr.set(j,temp);
    }
}


//Better Approach

class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
      List<List<Integer>>res=new ArrayList<>();
      
      List<Integer>arr=new ArrayList<>();
      for (int num : nums)
        arr.add(num);

      findAllPermutation(arr, 0, (arr.size()-1),res);

     return res;
    }

    private void findAllPermutation(List<Integer>arr, int start, int end,List<List<Integer>>res)
    {
        if (start == end)
        {
          List<Integer>perm=new ArrayList<>(arr);
          if(res.contains(perm)==false)
            res.add(perm);
        }
        else 
        {
          for (int i = start; i <= end; i++)
          {
            swap(arr, start, i);
            findAllPermutation(arr, start + 1, end,res);
            swap(arr, start, i);
          }
        }
    }

    public void swap(List<Integer>arr, int i, int j)
    {
        int temp = arr.get(i);
        arr.set(i,arr.get(j));
        arr.set(j,temp);
    }
}

//Optimal Approach

class Solution {
    public List<List<Integer>> permuteUnique(int[] arr) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(arr); // Sort the input array to handle duplicates
        boolean[] used = new boolean[arr.length];

        findAllPermutation(arr, used, new ArrayList<>(), res);
        return res;
    }

    private void findAllPermutation(int[] arr, boolean[] used, List<Integer> perm, List<List<Integer>> res)
    {
        if (perm.size() == arr.length)
            res.add(new ArrayList<>(perm)); 
        else
        {
            for (int i = 0; i < arr.length; i++)
            {
                if (used[i] || (i > 0 && arr[i] == arr[i - 1] && !used[i - 1]))
                  continue; // Skip duplicates and already used elements
                
                used[i] = true;
                perm.add(arr[i]);
                findAllPermutation(arr, used, perm, res);
                perm.remove(perm.size() - 1);
                used[i] = false;
            }
        }
    }
}
