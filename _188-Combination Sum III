//Recursive Approach

//Method 1

//Naive Implementation

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> subsets = new ArrayList<>();
        generateSubsets(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9}, 0, new ArrayList<>(), subsets);
        findKSizeSubsets(subsets, k);
        findTargetSumSubsets(subsets, n);
        return subsets;
    }

    private void generateSubsets(int[] arr, int index, List<Integer> currentSubset, List<List<Integer>> subsets) {
        if (index == arr.length) {
            subsets.add(new ArrayList<>(currentSubset));
            return;
        }

        currentSubset.add(arr[index]);
        generateSubsets(arr, index + 1, currentSubset, subsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSubsets(arr, index + 1, currentSubset, subsets);
    }

    private void findKSizeSubsets(List<List<Integer>> subsets, int k) {
        Iterator<List<Integer>> iterator = subsets.iterator();
        while (iterator.hasNext()) {
            if (iterator.next().size() != k) {
                iterator.remove();
            }
        }
    }

    private void findTargetSumSubsets(List<List<Integer>> kSizeSubsets, int target) {
        Iterator<List<Integer>> iterator = kSizeSubsets.iterator();

        while (iterator.hasNext()) {
            if (findSubsetSum(iterator.next()) != target) {
                iterator.remove();
            }
        }
    }

    private int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }

        return subsetSum;
    }
}


//Improved Implementation

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> subsets = new ArrayList<>();
        generateSubsets(1, new ArrayList<>(), subsets);
        findKSizeTargetSumSubsets(subsets, k, n);
        return subsets;
    }

    private void generateSubsets(int currentNumber, List<Integer> currentSubset, List<List<Integer>> subsets) {
        if (currentNumber > 9) {
            subsets.add(new ArrayList<>(currentSubset));
            return;
        }

        currentSubset.add(currentNumber);
        generateSubsets(currentNumber + 1, currentSubset, subsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSubsets(currentNumber + 1, currentSubset, subsets);
    }

    private void findKSizeTargetSumSubsets(List<List<Integer>> subsets, int k, int target) {
        Iterator<List<Integer>> iterator = subsets.iterator();
        while (iterator.hasNext()) {
            List<Integer>currentSubset=iterator.next();
            if (currentSubset.size() != k || (currentSubset.size() == k && findSubsetSum(currentSubset) != target)){
                iterator.remove();
            }
        }
    }

    private int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }

        return subsetSum;
    }
}

//Good Implemenation

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> sizeKSubsets = new ArrayList<>();
        generateSizeKSubsets(1, k, new ArrayList<>(), sizeKSubsets);
        findTargetSumSubsets(sizeKSubsets, n);
        return sizeKSubsets;
    }

    private void generateSizeKSubsets(int currentNumber, int k, List<Integer> currentSubset, List<List<Integer>> sizeKSubsets) {
        if (currentNumber > 9) {
            if (currentSubset.size() == k) {
                sizeKSubsets.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        currentSubset.add(currentNumber);
        generateSizeKSubsets(currentNumber + 1, k, currentSubset, sizeKSubsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSizeKSubsets(currentNumber + 1, k, currentSubset, sizeKSubsets);
    }

    private void findTargetSumSubsets(List<List<Integer>> subsets, int target) {
        Iterator<List<Integer>> iterator = subsets.iterator();
        while (iterator.hasNext()) {
            if (findSubsetSum(iterator.next()) != target) {
                iterator.remove();
            }
        }
    }

    private int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }

        return subsetSum;
    }
}


//Better Implementation

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> sizeKSubsets = new ArrayList<>();
        generateSizeKSubsets(1, k, new ArrayList<>(), sizeKSubsets);
        findTargetSumSubsets(sizeKSubsets, n);
        return sizeKSubsets;
    }

    private void generateSizeKSubsets(int currentNumber, int k, List<Integer> currentSubset, List<List<Integer>> sizeKSubsets) {
        if (currentSubset.size() == k) {
            sizeKSubsets.add(new ArrayList<>(currentSubset));
            return;
        }

        if (currentSubset.size() > k || currentNumber > 9) {
            return;
        }

        currentSubset.add(currentNumber);
        generateSizeKSubsets(currentNumber + 1, k, currentSubset, sizeKSubsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSizeKSubsets(currentNumber + 1, k, currentSubset, sizeKSubsets);
    }

    private void findTargetSumSubsets(List<List<Integer>> subsets, int target) {
        Iterator<List<Integer>> iterator = subsets.iterator();
        while (iterator.hasNext()) {
            if (findSubsetSum(iterator.next()) != target) {
                iterator.remove();
            }
        }
    }

    private int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }

        return subsetSum;
    }
}


//Best Implementation

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> sizeKTargetSumSubsets = new ArrayList<>();
        generateSizeKTargetSumSubsets(1, k, n, new ArrayList<>(), sizeKTargetSumSubsets);
        return sizeKTargetSumSubsets;
    }

    private void generateSizeKTargetSumSubsets(int currentNumber, int k, int target, List<Integer> currentSubset, List<List<Integer>> sizeKTargetSumSubsets) {
        if (currentSubset.size() == k && target == 0) {
            sizeKTargetSumSubsets.add(new ArrayList<>(currentSubset));
            return;
        }

        if (currentSubset.size() > k || currentNumber > 9) {
            return;
        }

        currentSubset.add(currentNumber);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target - currentNumber, currentSubset,
                sizeKTargetSumSubsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target, currentSubset, sizeKTargetSumSubsets);
    }
}


//Further Optimised

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> sizeKTargetSumSubsets = new ArrayList<>();
        generateSizeKTargetSumSubsets(1, k, n, new ArrayList<>(), sizeKTargetSumSubsets);
        return sizeKTargetSumSubsets;
    }

    private void generateSizeKTargetSumSubsets(int currentNumber, int k, int target, List<Integer> currentSubset, List<List<Integer>> sizeKTargetSumSubsets) {
        if (currentSubset.size() == k && target == 0) {
            sizeKTargetSumSubsets.add(new ArrayList<>(currentSubset));
            return;
        }

        if (currentSubset.size() > k || target < 0 || currentNumber >9) {
            return;
        }

        currentSubset.add(currentNumber);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target - currentNumber, currentSubset, sizeKTargetSumSubsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target, currentSubset, sizeKTargetSumSubsets);
    }
}


//Optimal Approach

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> sizeKTargetSumSubsets = new ArrayList<>();
        generateSizeKTargetSumSubsets(1, k, n, new ArrayList<>(), sizeKTargetSumSubsets);
        return sizeKTargetSumSubsets;
    }

    private void generateSizeKTargetSumSubsets(int currentNumber, int k, int target, List<Integer> currentSubset, List<List<Integer>> sizeKTargetSumSubsets) {
        if (currentSubset.size() == k && target == 0) {
            sizeKTargetSumSubsets.add(new ArrayList<>(currentSubset));
            return;
        }

        if (currentSubset.size() > k || currentNumber > 9 || currentNumber > target) {
            return;
        }

        currentSubset.add(currentNumber);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target - currentNumber, currentSubset, sizeKTargetSumSubsets);
        currentSubset.remove(currentSubset.size() - 1);
        generateSizeKTargetSumSubsets(currentNumber + 1, k, target, currentSubset, sizeKTargetSumSubsets);
    }
}



//Method 2

