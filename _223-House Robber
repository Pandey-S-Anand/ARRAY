//Bruteforce Approach

//Forward recursion

class Solution {
    public int rob(int[] arr) {
        return rob(arr, 0);
    }

    private int rob(int[] arr, int index) {
        // Base case: if the index is out of bounds, return 0 because there are no more houses to rob
        if (index >= arr.length) {
            return 0;
        }
        
        // Option 1: Rob the current house (arr[index]) and move to the next house that can be robbed, i.e., index + 2
        int rob = arr[index] + rob(arr, index + 2);
        // Option 2: Skip the current house and move to the next house, i.e., index + 1
        int notRob = rob(arr, index + 1);
        
        // Return the maximum of robbing the current house or skipping it
        return Math.max(rob, notRob);
    }
}

//Backward recursion

class Solution {
    public int rob(int[] arr) {
        return rob(arr, arr.length - 1);
    }

    private int rob(int[] arr, int index) {
        // Base case: if the index is out of bounds, return 0 because there are no more houses to rob
        if (index < 0) {
            return 0;
        }

        // Option 1: Rob the current house (arr[index]) and move to the next house that can be robbed, i.e., index - 2
        int rob = arr[index] + rob(arr, index - 2);
        // Option 2: Skip the current house and move to the next house, i.e., index - 1
        int notRob = rob(arr, index - 1);

        // Return the maximum of robbing the current house or skipping it
        return Math.max(rob, notRob);
    }
}


//Better Approach

//Forward recursion

class Solution {
    private int[] cache;

    public int rob(int[] arr) {
        cache = new int[arr.length];
        Arrays.fill(cache, -1);
        return rob(arr, 0);
    }

    private int rob(int[] arr, int index) {
        if (index >= arr.length) {
            return 0;
        }

        if (cache[index] != -1) {
            return cache[index];
        }

        int rob = arr[index] + rob(arr, index + 2);
        int notRob = rob(arr, index + 1);

        return cache[index] = Math.max(rob, notRob);
    }
}

//Backward recursion 

class Solution {
    private int[] cache;

    public int rob(int[] arr) {
        cache = new int[arr.length];
        Arrays.fill(cache, -1);
        return rob(arr, arr.length - 1);
    }

    private int rob(int[] arr, int index) {
        if (index < 0) {
            return 0;
        }

        if (cache[index] != -1) {
            return cache[index];
        }

        int rob = arr[index] + rob(arr, index - 2);
        int notRob = rob(arr, index - 1);

        return cache[index] = Math.max(rob, notRob);
    }
}


//Optmal Approach

class Solution {
    public int rob(int[] arr) {
        //dp[i] represents the maximum money that can be robbed up to house i
        int[] dp = new int[arr.length];

        for (int i = 0; i < arr.length; i++) {
            int rob = arr[i];
            if (i - 2 >= 0) {
                rob += dp[i - 2];
            }

            int notRob = 0;
            if (i - 1 >= 0) {
                notRob = dp[i - 1];
            }

            dp[i] = Math.max(rob, notRob);
        }

        return dp[arr.length - 1];
    }
}

//Aliter (Space optimised)

class Solution {
    public int rob(int[] arr) {
        int prev2 = 0, prev1 = 0, current = 0;

        for (int i = 0; i < arr.length; i++) {
            int rob = arr[i] + prev2;
            int notRob = prev1;

            current = Math.max(rob, notRob);
            prev2 = prev1;
            prev1 = current;
        }

        return prev1;
    }
}
