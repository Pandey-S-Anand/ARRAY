//Bruteforce Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        for (int num = 1; num <= arr.length; num++) {
            boolean missing = true;
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] == num) {
                    missing = false;
                    break;
                }
            }

            if (missing) {
                return num;
            }
        }
        return arr.length + 1;
    }
}


//Improved Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        Set<Integer> set = new HashSet<>();
        for (int num : arr) {
            set.add(num);
        }

        for (int num = 1; num <= arr.length; num++) {
            if (!set.contains(num)) {
                return num;
            }
        }

        return arr.length + 1;
    }
}


//Good Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        Arrays.sort(arr);
        int num = 1, previous = 0;

        for (int val : arr) {
            if (val <= 0) {
                continue;
            }

            if (val != previous) {
                if (val != num) {
                    return num;
                }
                previous = val;
                num++;
            }
        }

        return num;
    }
}


//Better Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
      int countNonPos=segPosAndNonPos(arr);
      return findMissing(arr,countNonPos);
    }

    public static int segPosAndNonPos(int[]arr)
    {
       int n=arr.length,j=0;
       for(int i=0;i<n;i++)
	 if(arr[i]<=0)
	 {
	    int temp=arr[i];
	    arr[i]=arr[j];
	    arr[j]=temp;
	    j++;
	 }
	     
	return j; 
     }
	
     public static int findMissing(int[]arr,int start)
     {
        int n=arr.length,size=n-start;
        boolean[]visited=new boolean[size];
           
        for(int i=start;i<n;i++)
        {
           int x=arr[i];
           if(x<=size && visited[x-1]==false)  //(visited[x-1]==false) is Optional Condition to handle duplicates
              visited[x-1] =true;
        }
        
        for(int i=0; i <size; i++)
          if(visited[i]==false)
            return i+1;
	  
        //if all indices are marked, then smallest missing positive number is array size + 1. 
        return size+1;
     }
}


//Optimal Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
      int countNonPos=segPosAndNonPos(arr);
      return findMissing(arr,countNonPos);   
    }

    public static int segPosAndNonPos(int[]arr)
    {
	int n=arr.length,j=0;
	for(int i=0;i<n;i++)
	   if(arr[i]<=0)
	   {
	      int temp=arr[i];
	      arr[i]=arr[j];
	      arr[j]=temp;
	      j++;
	   }
	     
       return j; 
    }
	
    public static int findMissing(int[]arr,int start)
    {
        int n=arr.length,newSize=(n-start);

        for(int i=start;i<n;i++)
        {
            int x = Math.abs(arr[i]);
            if (x<=newSize && arr[start+(x-1)] > 0)
              arr[start+(x-1)] = -arr[start+(x-1)];
        }
        
        for (int i = start; i <n; i++)
          if (arr[i]>0)
             return ((i+1)-start); 
		
        return (newSize+1);
    }
}
