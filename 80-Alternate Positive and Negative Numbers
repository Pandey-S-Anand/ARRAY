// Bruteforce Approach(Order of Appearence is Maintained)

class Solution {
    void rearrange(int arr[], int n) {
        List<Integer> positiveList = new ArrayList<>();
        List<Integer> negativeList = new ArrayList<>();

        for (int val : arr) {
            if (val >= 0) {
                positiveList.add(val);
            } else {
                negativeList.add(val);
            }
        }

        if (positiveList.size() == n || negativeList.size() == n) {
            return;
        }

        int arrIndex = 0, posIndex = 0, negIndex = 0;

        while (posIndex < positiveList.size() && negIndex < negativeList.size()) {
            arr[arrIndex++] = positiveList.get(posIndex++);
            arr[arrIndex++] = negativeList.get(negIndex++);
        }

        while (posIndex < positiveList.size()) {
            arr[arrIndex++] = positiveList.get(posIndex++);
        }

        while (negIndex < negativeList.size()) {
            arr[arrIndex++] = negativeList.get(negIndex++);
        }
    }
}


//Good Approach(Order of Appearence is Maintained)

class Solution {
    void rearrange(int arr[], int n) {
        int firstNegativeIndex = segregateMaintainingOrder(arr, n);

        if (firstNegativeIndex == n) {
            return;
        }

        int[] result = new int[n];
        int positiveIndex = 0, negativeIndex = firstNegativeIndex, resultIndex = 0;

        while (positiveIndex < firstNegativeIndex && negativeIndex < n) {
            result[resultIndex++] = arr[positiveIndex++];
            result[resultIndex++] = arr[negativeIndex++];
        }

        while (positiveIndex < firstNegativeIndex) {
            result[resultIndex++] = arr[positiveIndex++];
        }

        while (negativeIndex < n) {
            result[resultIndex++] = arr[negativeIndex++];
        }

        System.arraycopy(result, 0, arr, 0, n);
    }

    private int segregateMaintainingOrder(int arr[], int n) {
        int negativeTracker = 0;

        for (int i = 0; i < n; i++) { // 'negativeTracker' is tracking the +ve Elemnent while 'i' is used for iterating over the array
            if (arr[i] >= 0) {
                // This leftShiftBy1() method maintains the order of appearence
                leftShiftBy1(arr, negativeTracker, i);
                negativeTracker++;
            }
        }

        return negativeTracker;
    }

    private void leftShiftBy1(int[] arr, int start, int end) {
        int temp = arr[end];
        for (int i = end; i > start; i--) {
            arr[i] = arr[i - 1];
        }

        arr[start] = temp;
    }
}


//Better Approach(Order of Appearence is Maintained)

class Solution {
    void rearrange(int arr[], int n) {
        segregateMaintainingOrder(arr, n);
        int firstNegativeIndex = findFirstNegativeIndex(arr, n);

        if (firstNegativeIndex == n) {
            return;
        }

        int[] result = new int[n];
        int positiveIndex = 0, negativeIndex = firstNegativeIndex, resultIndex = 0;

        while (positiveIndex < firstNegativeIndex && negativeIndex < n) {
            result[resultIndex++] = arr[positiveIndex++];
            result[resultIndex++] = arr[negativeIndex++];
        }

        while (positiveIndex < firstNegativeIndex) {
            result[resultIndex++] = arr[positiveIndex++];
        }

        while (negativeIndex < n) {
            result[resultIndex++] = arr[negativeIndex++];
        }

        System.arraycopy(result, 0, arr, 0, n);
    }

    private void segregateMaintainingOrder(int[] arr, int n) {
        mergeSort(arr, 0, n - 1);
    }

    private void mergeSort(int[] arr, int lb, int ub) {
        if (lb < ub) {
            int mid = lb + (ub - lb) / 2;
            mergeSort(arr, lb, mid);
            mergeSort(arr, mid + 1, ub);
            modifiedMerge(arr, lb, mid, ub);
        }
    }

    private void modifiedMerge(int[] arr, int lb, int mid, int ub) {
        int leftSize = (mid - lb + 1), rightSize = (ub - mid);
        int[] left = new int[leftSize];
        int[] right = new int[rightSize];

        for (int i = 0; i < leftSize; i++) {
            left[i] = arr[lb + i];
        }

        for (int i = 0; i < rightSize; i++) {
            right[i] = arr[mid + 1 + i];
        }

        int posIndex = 0, negIndex = 0, arrIndex = lb;
        // copy positive elements of left sublist
        while (posIndex < leftSize && left[posIndex] >= 0) {
            arr[arrIndex++] = left[posIndex++];
        }

        // copy positive elements of right sublist
        while (negIndex < rightSize && right[negIndex] >= 0) {
            arr[arrIndex++] = right[negIndex++];
        }

        // Copy negative elements of left sublist
        while (posIndex < leftSize) {
            arr[arrIndex++] = left[posIndex++];
        }

        // Copy negative elements of right sublist
        while (negIndex < rightSize) {
            arr[arrIndex++] = right[negIndex++];
        }
    }

    private int findFirstNegativeIndex(int[] arr, int n) {
        for (int i = 0; i < n; i++) {
            if (arr[i] < 0) {
                return i;
            }
        }
        return n; // Return n if no negative number is found
    }
}


// Optimal Approach (Order of Appearence is Maintained)

/*
in rearranged array Positive elements are found at Even index(0,2,4,6,8..) and Negative Elements are found at odd index(1,3,5,7,9...)
The idea is to process array from left to right. While processing, find the first out of place element in the remaining unprocessed array.
An element is out of place if it is positive and at odd index (0 based index), or it is negative and at even index (0 based index) .
Once we find an out of place element, we find the first element after it with opposite sign. 
We right rotate the subarray between these two elements (including these two).
*/


class Solution {
    void rearrange(int arr[], int n) {
        int wrongIndex = -1;// No Wrong Index

        for (int i = 0; i < n; i++) {
            if (wrongIndex != -1) {
                if ((arr[wrongIndex] < 0 && arr[i] >= 0) || (arr[wrongIndex] >= 0 && arr[i] < 0)) {
                    rightRotate(arr, wrongIndex, i);
                    if ((i - wrongIndex) == 1) {
                        wrongIndex = -1;
                    } else {  //((i - wrongIndex)>= 2)
                        wrongIndex += 2;
                    }
                }
            }

            if (wrongIndex == -1) {
                if (((i % 2) == 0 && arr[i] < 0) || ((i % 2) == 1 && arr[i] >= 0)) {
                    wrongIndex = i;
                }
            }
        }
    }

    private void rightRotate(int[] arr, int wrongIndex, int index) {
        int temp = arr[index];
        for (int i = index; i > wrongIndex; i--) {
            arr[i] = arr[i - 1];
        }

        arr[wrongIndex] = temp;
    }
}
