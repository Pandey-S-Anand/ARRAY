/*
Given the constraints that the product will fit in a 32-bit integer, it's crucial to check if the product is within the int range (Integer.MAX_VALUE and Integer.MIN_VALUE).
If it exceeds this range, it should be ignored for the purpose of determining the maximum product subarray.
*/

//Bruteforce Approach

class Solution {
    public int maxProduct(int[] arr) {
        int maxSubArrayProduct = Integer.MIN_VALUE;
        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                long subArrayProduct = 1;
                for (int range = start; range <= end; range++) {
                    subArrayProduct *= arr[range];
                }

                if (subArrayProduct >= Integer.MIN_VALUE && subArrayProduct <= Integer.MAX_VALUE) {
                    maxSubArrayProduct = Math.max(maxSubArrayProduct, (int) subArrayProduct);
                }
            }
        }

        return maxSubArrayProduct;
    }
}



//Better Approach

class Solution {
    public int maxProduct(int[] arr) {
        int maxSubArrayProduct = Integer.MIN_VALUE;
        for (int start = 0; start < arr.length; start++) {
            long subArrayProduct = 1;
            for (int end = start; end < arr.length; end++) {
                subArrayProduct *= arr[end];
                if (subArrayProduct <= Integer.MAX_VALUE && subArrayProduct >= Integer.MIN_VALUE) {
                    maxSubArrayProduct = Math.max(maxSubArrayProduct, (int) subArrayProduct);
                }
            }
        }
        return maxSubArrayProduct;
    }
}


//Good Approach

class Solution {
    public int maxProduct(int[] arr) {
        long currentProduct = 1;
        int maximumProduct = Integer.MIN_VALUE;

        for (int val : arr) {
            if (currentProduct == 0) {
                currentProduct = val;
            } else {
                currentProduct *= val;
            }

            if (currentProduct >= Integer.MIN_VALUE && currentProduct <= Integer.MAX_VALUE) {
                maximumProduct = Math.max((int) currentProduct, maximumProduct);
            }
        }

        currentProduct = 1;

        for (int i = arr.length - 1; i >= 0; i--) {
            if (currentProduct == 0) {
                currentProduct = arr[i];
            } else {
                currentProduct *= arr[i];
            }

            if (currentProduct >= Integer.MIN_VALUE && currentProduct <= Integer.MAX_VALUE) {
                maximumProduct = Math.max((int) currentProduct, maximumProduct);
            }
        }

        return maximumProduct;
    }
}


//Optimal Approach

class Solution {
    public int maxProduct(int[] arr) {
      int n=arr.length,maxProdSoFar=1,minProdSoFar=1,maxProd=Integer.MIN_VALUE;
	  
      for(int i=0;i<n;i++)
      {
	 int temp=maxProdSoFar;
	    
	 maxProdSoFar=maximum(arr[i],maxProdSoFar*arr[i],minProdSoFar*arr[i]);
	 minProdSoFar=minimum(arr[i],temp*arr[i],minProdSoFar*arr[i]);
	    
	 if(maxProdSoFar>maxProd)
	    maxProd=maxProdSoFar;
	    
	 if(arr[i]==0)
	 {
	    maxProdSoFar=1;
	    minProdSoFar=1;
	 }  
      }
	  
     return maxProd;  
    }

    public int maximum(int x,int y,int z)
    {
      return Math.max(x,Math.max(y,z));
    }
	
    public int minimum(int x,int y,int z)
    {
      return Math.min(x,Math.min(y,z));
    }
}
