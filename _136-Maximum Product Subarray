/*
Given the constraints that the product will fit in a 32-bit integer, it's crucial to check if the product is within the int range (Integer.MAX_VALUE and Integer.MIN_VALUE).
If it exceeds this range, it should be ignored for the purpose of determining the maximum product subarray.
*/

//Bruteforce Approach

class Solution {
    public int maxProduct(int[] arr) {
        int maxSubArrayProduct = Integer.MIN_VALUE;
        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                long subArrayProduct = 1;
                for (int range = start; range <= end; range++) {
                    subArrayProduct *= arr[range];
                }

                if (subArrayProduct >= Integer.MIN_VALUE && subArrayProduct <= Integer.MAX_VALUE) {
                    maxSubArrayProduct = Math.max(maxSubArrayProduct, (int) subArrayProduct);
                }
            }
        }

        return maxSubArrayProduct;
    }
}



//Better Approach

class Solution {
    public int maxProduct(int[] arr) {
        int maxSubArrayProduct = Integer.MIN_VALUE;
        for (int start = 0; start < arr.length; start++) {
            long subArrayProduct = 1;
            for (int end = start; end < arr.length; end++) {
                subArrayProduct *= arr[end];
                if (subArrayProduct <= Integer.MAX_VALUE && subArrayProduct >= Integer.MIN_VALUE) {
                    maxSubArrayProduct = Math.max(maxSubArrayProduct, (int) subArrayProduct);
                }
            }
        }
        return maxSubArrayProduct;
    }
}


//Good Approach

class Solution {
    public int maxProduct(int[] arr) {
      int n=arr.length,currProd=1,maxProd=Integer.MIN_VALUE;
      for(int i=0;i<n;i++)
      {
        if(currProd!=0)
          currProd*=arr[i];
        else
          currProd=arr[i];
        
        if(currProd>maxProd)
          maxProd=currProd;
      }
      
      currProd=1;
      for(int i=n-1;i>=0;i--)
      {
        if(currProd!=0)
          currProd*=arr[i];
        else
          currProd=arr[i];
        
        if(currProd>maxProd)
          maxProd=currProd;
      }
      
     return maxProd;
    }
}


//Optimal Approach

class Solution {
    public int maxProduct(int[] arr) {
      int n=arr.length,maxProdSoFar=1,minProdSoFar=1,maxProd=Integer.MIN_VALUE;
	  
      for(int i=0;i<n;i++)
      {
	 int temp=maxProdSoFar;
	    
	 maxProdSoFar=maximum(arr[i],maxProdSoFar*arr[i],minProdSoFar*arr[i]);
	 minProdSoFar=minimum(arr[i],temp*arr[i],minProdSoFar*arr[i]);
	    
	 if(maxProdSoFar>maxProd)
	    maxProd=maxProdSoFar;
	    
	 if(arr[i]==0)
	 {
	    maxProdSoFar=1;
	    minProdSoFar=1;
	 }  
      }
	  
     return maxProd;  
    }

    public int maximum(int x,int y,int z)
    {
      return Math.max(x,Math.max(y,z));
    }
	
    public int minimum(int x,int y,int z)
    {
      return Math.min(x,Math.min(y,z));
    }
}
