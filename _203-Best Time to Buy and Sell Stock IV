//Bruteforce Approach

class Solution {
    public int maxProfit(int k, int[] prices) {
        return calculateMaxProfit(0, prices, 1, k);
    }

    private int calculateMaxProfit(int index, int[] prices, int canBuy, int transactionCount) {
        if (transactionCount == 0 || index == prices.length) {
            return 0;
        }

        if (canBuy == 1) {
            int buyStock = -prices[index] + calculateMaxProfit(index + 1, prices, 0, transactionCount);
            int skipBuy = calculateMaxProfit(index + 1, prices, 1, transactionCount);
            return Math.max(buyStock, skipBuy);
        }

        int sellStock = prices[index] + calculateMaxProfit(index + 1, prices, 1, transactionCount - 1);
        int skipSell = calculateMaxProfit(index + 1, prices, 0, transactionCount);
        return Math.max(sellStock, skipSell);
    }
}


//Better Approach

class Solution {
    private int[][][] memo;

    public int maxProfit(int k, int[] prices) {
        memo = new int[prices.length][2][k + 1];
        intializeMemo();
        return calculateMaxProfit(0, prices, 1, k);
    }

    private int calculateMaxProfit(int index, int[] prices, int canBuy, int transactionCount) {
        if (transactionCount == 0 || index == prices.length) {
            return 0;
        }

        if (memo[index][canBuy][transactionCount] != -1) {
            return memo[index][canBuy][transactionCount];
        }

        if (canBuy == 1) {
            int buyStock = -prices[index] + calculateMaxProfit(index + 1, prices, 0, transactionCount);
            int skipBuy = calculateMaxProfit(index + 1, prices, 1, transactionCount);
            return memo[index][canBuy][transactionCount] = Math.max(buyStock, skipBuy);
        }

        int sellStock = prices[index] + calculateMaxProfit(index + 1, prices, 1, transactionCount - 1);
        int skipSell = calculateMaxProfit(index + 1, prices, 0, transactionCount);
        return memo[index][canBuy][transactionCount] = Math.max(sellStock, skipSell);
    }

    private void intializeMemo() {
        for (int i = 0; i < memo.length; i++) {
            for (int j = 0; j < memo[0].length; j++) {
                Arrays.fill(memo[i][j], -1);
            }
        }
    }
}


//Optimal Approach

//Naive Implementation

class Solution {
    public int maxProfit(int k, int[] prices) {
        /*
         * dp[day][canBuy][txnCount] represents the maximum profit achievable on a given day with specific conditions:
         *
         * - If canBuy = 1, it means you are allowed to buy stock on that day. In this case, you have two options:
         *   1. Buy the stock, which incurs a cost equal to the stock's price.
         *   2. Skip buying the stock, maintaining your current profit.
         * 
         * - If canBuy = 0, it means you are not allowed to buy stock on that day (i.e., you can only sell the stock). In this scenario, you also have two options:
         *   1. Sell the stock, which will increase your profit by the current stock price.
         *   2. Skip selling the stock, which means your profit remains the same as the previous day.
         * 
         * - txnCount: The number of transactions completed so far (up to k transactions are allowed).
         */
        int[][][] dp = new int[prices.length][2][k + 1];

        /*
         * On the first trading day, we have the option to buy the stock as we dont hold any stock 
         * If we choose to skip buying on the first day, our profit will remain zero, regardless of the number of transactions.
         * However, if we choose to buy the stock, we incur the cost of purchasing it,
         * which results in a negative profit, since profit is calculated as: profit = selling price - buying price.
         */

        for (int canBuy = 0; canBuy <= 1; canBuy++) {
            for (int txnCount = 0; txnCount <= k; txnCount++) {
                if (canBuy == 0) {
                    dp[0][canBuy][txnCount] = 0;
                } else {
                    dp[0][canBuy][txnCount] = -prices[0];
                }
            }
        }

        for (int day = 1; day < prices.length; day++) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                for (int txnCount = 0; txnCount <= k; txnCount++) {
                    int profit;
                    if (canBuy == 1) {
                        int skipBuy = dp[day - 1][1][txnCount];
                        int buyStock = dp[day - 1][0][txnCount] - prices[day];
                        profit = Math.max(skipBuy, buyStock);
                    } else {
                        int skipSell = dp[day - 1][0][txnCount];
                        int sellStock = 0;
                        if (txnCount > 0) {
                            sellStock = dp[day - 1][1][txnCount - 1] + prices[day];
                        }
                        profit = Math.max(skipSell, sellStock);
                    }

                    dp[day][canBuy][txnCount] = profit;
                }
            }
        }
        // Result: Maximum profit on the last day, with all stocks sold and a maximum of k transactions completed.
        return dp[prices.length - 1][0][k];
    }
}

//Optimal Implementation 

class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][][] dp = new int[prices.length][2][k + 1];

        for (int canBuy = 0; canBuy <= 1; canBuy++) {
            for (int txnCount = 0; txnCount <= k; txnCount++) {
                if (canBuy == 0) {
                    dp[0][canBuy][txnCount] = 0;
                } else {
                    dp[0][canBuy][txnCount] = -prices[0];
                }
            }
        }

        for (int day = 1; day < prices.length; day++) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                for (int txnCount = 0; txnCount <= k; txnCount++) {
                    if (canBuy == 1) {
                        dp[day][canBuy][txnCount] = Math.max(dp[day - 1][1][txnCount], dp[day - 1][0][txnCount] - prices[day]);
                    } else {
                        dp[day][canBuy][txnCount] = dp[day - 1][0][txnCount];
                        if (txnCount > 0) {
                            dp[day][canBuy][txnCount] = Math.max(dp[day][canBuy][txnCount], dp[day - 1][1][txnCount - 1] + prices[day]);
                        }
                    }
                }
            }
        }

        return dp[prices.length - 1][0][k];
    }
}


//Aliter (space optimised : 3D to 2 2D array)

class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][] previousRow = new int[2][k + 1];
        int[][] currentRow = new int[2][k + 1];

        for (int canBuy = 0; canBuy <= 1; canBuy++) {
            for (int txnCount = 0; txnCount <= k; txnCount++) {
                if (canBuy == 0) {
                    previousRow[canBuy][txnCount] = 0;
                } else {
                    previousRow[canBuy][txnCount] = -prices[0];
                }
            }
        }

        for (int day = 1; day < prices.length; day++) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                for (int txnCount = 0; txnCount <= k; txnCount++) {
                    if (canBuy == 1) {
                        currentRow[1][txnCount] = Math.max(previousRow[1][txnCount], previousRow[0][txnCount] - prices[day]);
                    } else {
                        currentRow[0][txnCount] = previousRow[0][txnCount];
                        if (txnCount > 0) {
                            currentRow[0][txnCount] = Math.max(currentRow[0][txnCount], previousRow[1][txnCount - 1] + prices[day]);
                        }
                    }
                }
            }
            
            int[][] temp = currentRow;
            currentRow = previousRow;
            previousRow = temp;
        }

        return previousRow[0][k];
    }
}


//Aliter (space optimised : 2 2D array to 1 2D array)

class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][] dp = new int[2][k + 1];

        for (int canBuy = 0; canBuy <= 1; canBuy++) {
            for (int txnCount = 0; txnCount <= k; txnCount++) {
                if (canBuy == 0) {
                    dp[canBuy][txnCount] = 0;
                } else {
                    dp[canBuy][txnCount] = -prices[0];
                }
            }
        }

        for (int day = 1; day < prices.length; day++) {
            for (int canBuy = 0; canBuy <= 1; canBuy++) {
                for (int txnCount = 0; txnCount <= k; txnCount++) {
                    if (canBuy == 1) {
                        dp[1][txnCount] = Math.max(dp[1][txnCount], dp[0][txnCount] - prices[day]);
                    } else {
                        if (txnCount > 0) {
                            dp[0][txnCount] = Math.max(dp[0][txnCount], dp[1][txnCount - 1] + prices[day]);
                        }
                    }
                }
            }
        }

        return dp[0][k];
    }
}
