//Bruteforce Approach

class Solution {
    int findMaximum(int[] arr, int n) {
        Arrays.sort(arr);
        return arr[n - 1]; // Maximum element
    }
}


//Improved Approach

class Solution {
    int findMaximum(int[] arr, int n) {
        int low = 0, high = n - 1, maximum = Integer.MIN_VALUE;

        while (low <= high) {
            maximum = Math.max(maximum, Math.max(arr[low++], arr[high--]));
        }

        return maximum;
    }
}


//Good Approach

class Solution {
    int findMaximum(int[] arr, int n) {
        return arr[findBitonicPoint(arr)];
    }
    
    private int findBitonicPoint(int[] arr) {
      for(int i=0;i<arr.length-1;i++){
          if(arr[i]>arr[i+1]){
             return i; 
          }
      }
      return arr.length-1;
    }
}


//Better Approach

