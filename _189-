//Bruteforce Approach

//Naive Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>());

        for (int i = 0; i < n; i++) {
            int size = subsets.size();
            for (int j = 0; j < size; j++) {
                List<Integer> currentSubset = new ArrayList<>(subsets.get(j));
                currentSubset.add(arr[i]);
                if (findSubsetSum(currentSubset) == targetSum) {
                    return true;
                }
                subsets.add(currentSubset);
            }
        }

        return false;
    }

    private static int findSubsetSum(List<Integer> subset) {
        int subsetSum = 0;
        for (int val : subset) {
            subsetSum += val;
        }
        return subsetSum;
    }
}


//Optimal Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        Set<Integer> subsetsSum = new HashSet<>();
        subsetsSum.add(0);

        for (int i = 0; i < n; i++) {
            Set<Integer> existingSubsetsSum = new HashSet<>(subsetsSum);
            for (int subsetSum : existingSubsetsSum) {
                int newSubsetSum = subsetSum + arr[i];

                if (newSubsetSum == targetSum) {
                    return true;
                }

                if (newSubsetSum < targetSum) {
                    subsetsSum.add(newSubsetSum);
                }
            }
        }

        return false;
    }
}


//Improved Approach

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int n, int targetSum) {
        int currentSubsetSum = 0;
        int totalSubsets = 1 << arr.length; // x << y = x * 2^n

        for (int num = 0; num < totalSubsets; num++) {
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    currentSubsetSum += arr[i];
                    if (currentSubsetSum > targetSum) {
                        break;
                    }
                }
            }

            if (currentSubsetSum == targetSum) {
                return true;
            }

            currentSubsetSum = 0;
        }

        return false;
    }
}


//Good Approach

//Method 1

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, 0, n, 0, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int currentSubsetSum, int targetSum) {
        if (currentSubsetSum == targetSum) {
            return true;
        }

        if (index == n || currentSubsetSum > targetSum) {
            return false;
        }

        return hasSubsetWithTargetSum(arr, index + 1, n, currentSubsetSum + arr[index], targetSum)
                || hasSubsetWithTargetSum(arr, index + 1, n, currentSubsetSum, targetSum);
    }
}


//Aliter Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, 0, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (index == n || targetSum < 0) {
            return false;
        }

        return hasSubsetWithTargetSum(arr, index + 1, n, targetSum - arr[index])
                || hasSubsetWithTargetSum(arr, index + 1, n, targetSum);
    }
}


//Method 2


class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, 0, n, 0, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int currentSubsetSum, int targetSum) {
        if (currentSubsetSum == targetSum) {
            return true;
        }

        if (currentSubsetSum > targetSum) {
            return false;
        }

        for (int i = index; i < n; i++) {
            if(hasSubsetWithTargetSum(arr, i+1,n, currentSubsetSum+arr[i], targetSum)){
                return true;
            }
        }
        
        return false;
    }
}



//Aliter Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        return hasSubsetWithTargetSum(arr, 0, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (targetSum < 0) {
            return false;
        }

        for (int i = index; i < n; i++) {
            if (hasSubsetWithTargetSum(arr, i + 1, n, targetSum - arr[i])) {
                return true;
            }
        }

        return false;
    }
}


//Better Approach

//Method 1

class Solution {
    private static int[] memo;

    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        memo = new int[targetSum + 1];
        Arrays.fill(memo, -1);
        return hasSubsetWithTargetSum(arr, 0, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (index == n || targetSum < 0) {
            return false;
        }

        if (memo[targetSum] != -1) {
            return memo[targetSum] == 1;
        }

        memo[targetSum] = (hasSubsetWithTargetSum(arr, index + 1, n, targetSum - arr[index])
                || hasSubsetWithTargetSum(arr, index + 1, n, targetSum)) ? 1 : 0;

        return memo[targetSum] == 1;
    }
}


//Method 2


class Solution {
    private static int[] memo;

    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        memo = new int[targetSum + 1];
        Arrays.fill(memo, -1);
        return hasSubsetWithTargetSum(arr, 0, n, targetSum);
    }

    private static boolean hasSubsetWithTargetSum(int[] arr, int index, int n, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (targetSum < 0) {
            return false;
        }

        if (memo[targetSum] != -1) {
            return memo[targetSum] == 1;
        }

        for (int i = index; i < n; i++) {
            if (hasSubsetWithTargetSum(arr, i + 1, n, targetSum - arr[i])) {
                memo[targetSum] = 1;
                return true;
            }
        }
        memo[targetSum] = 0;
        return false;
    }
}


//Optimal Approach

//Naive Implementation

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        boolean[][] dp = new boolean[n + 1][targetSum + 1];

        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i <= targetSum; i++) {
            dp[0][i] = false;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= targetSum; j++) {
                if (j < arr[i - 1]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];
                }
            }
        }

        return dp[n][targetSum];
    }
}


//Optimal Implementation 

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        boolean[][] dp = new boolean[n + 1][targetSum + 1];

        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= targetSum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= arr[i - 1]) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j - arr[i - 1]];
                }
            }
        }

        return dp[n][targetSum];
    }
}


//Aliter (Space optimized)

class Solution {
    static Boolean isSubsetSum(int n, int arr[], int targetSum) {
        boolean[] peviousRow = new boolean[targetSum + 1];
        boolean[] currentRow = new boolean[targetSum + 1];

        peviousRow[0] = true;

        for (int i = 1; i <= n; i++) {
            currentRow[0] = true;
            for (int j = 1; j <= targetSum; j++) {
                currentRow[j] = peviousRow[j];
                if (j >= arr[i - 1]) {
                    currentRow[j] = currentRow[j] || peviousRow[j - arr[i - 1]];
                }
            }

            boolean[] temp = peviousRow;
            peviousRow = currentRow;
            currentRow = temp;
        }

        return peviousRow[targetSum];
    }
}
