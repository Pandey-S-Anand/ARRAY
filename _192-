//Recursive Approach

//Method 1

//Naive Implementation

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> allCombinations = new ArrayList<>();
        generateAllCombinations(new char[2 * n], 0, allCombinations);

        Iterator<String> iterator = allCombinations.iterator();

        while (iterator.hasNext()) {
            String combination = iterator.next();
            if (!isValidCombination(combination)) {
                iterator.remove();
            }
        }

        return allCombinations;
    }

    private void generateAllCombinations(char[] currentCombination, int index, List<String> combinations) {
        if (index == currentCombination.length) { // index == 2 * n
            combinations.add(new String(currentCombination));
            return;
        }

        currentCombination[index] = '(';
        generateAllCombinations(currentCombination, index + 1, combinations);
        currentCombination[index] = ')';
        generateAllCombinations(currentCombination, index + 1, combinations);
    }

    private boolean isValidCombination(String combination) {
        int balance = 0;

        for (char ch : combination.toCharArray()) {
            if (ch == '(') {
                balance++;
            } else {
                balance--;
            }

            if (balance < 0) {
                return false;
            }
        }

        return balance == 0;
    }
}

//Aliter

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> allCombinations = new ArrayList<>();
        generateAllCombinations(new StringBuilder(), 0, allCombinations, n);

        Iterator<String> iterator = allCombinations.iterator();

        while (iterator.hasNext()) {
            String combination = iterator.next();
            if (!isValidCombination(combination)) {
                iterator.remove();
            }
        }

        return allCombinations;
    }

    private void generateAllCombinations(StringBuilder currentCombination, int index, List<String> combinations, int n) {
        if (currentCombination.length() == 2 * n) { // index == 2 * n
            combinations.add(new String(currentCombination));
            return;
        }

        currentCombination.append('(');
        generateAllCombinations(currentCombination, index + 1, combinations, n);
        currentCombination.deleteCharAt(currentCombination.length() - 1);
        currentCombination.append(')');
        generateAllCombinations(currentCombination, index + 1, combinations, n);
        currentCombination.deleteCharAt(currentCombination.length() - 1);
    }

    private boolean isValidCombination(String combination) {
        int balance = 0;

        for (int i = 0; i < combination.length(); i++) {
            if (combination.charAt(i) == '(') {
                balance++;
            } else {
                balance--;
            }

            if (balance < 0) {
                return false;
            }
        }

        return balance == 0;
    }
}


//Optimal Implementation

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> validCombinations = new ArrayList<>();
        generateAllValidCombinations(new char[2 * n], 0, validCombinations);
        return validCombinations;
    }

    private void generateAllValidCombinations(char[] currentCombination, int index, List<String> validCombinations) {
        if (index == currentCombination.length) { // index == 2 * n
            if (isValidCombination(currentCombination)) {
                validCombinations.add(new String(currentCombination));
            }
            return;
        }

        currentCombination[index] = '(';
        generateAllValidCombinations(currentCombination, index + 1, validCombinations);
        currentCombination[index] = ')';
        generateAllValidCombinations(currentCombination, index + 1, validCombinations);
    }

    private boolean isValidCombination(char[] combination) {
        int balance = 0;

        for (char ch : combination) {
            if (ch == '(') {
                balance++;
            } else {
                balance--;
            }

            if (balance < 0) {
                return false;
            }
        }

        return balance == 0;
    }
}

//Aliter

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> validCombinations = new ArrayList<>();
        generateAllCombinations(new StringBuilder(), 0, validCombinations, n);
        return validCombinations;
    }

    private void generateAllCombinations(StringBuilder currentCombination, int index, List<String> validCombinations, int n) {
        if (currentCombination.length() == 2 * n) { // index == 2 * n
            if (isValidCombination(currentCombination)) {
                validCombinations.add(new String(currentCombination));
            }
            return;
        }

        currentCombination.append('(');
        generateAllCombinations(currentCombination, index + 1, validCombinations, n);
        currentCombination.deleteCharAt(currentCombination.length() - 1);
        currentCombination.append(')');
        generateAllCombinations(currentCombination, index + 1, validCombinations, n);
        currentCombination.deleteCharAt(currentCombination.length() - 1);
    }

    private boolean isValidCombination(StringBuilder combination) {
        int balance = 0;

        for (int i = 0; i < combination.length(); i++) {
            if (combination.charAt(i) == '(') {
                balance++;
            } else {
                balance--;
            }

            if (balance < 0) {
                return false;
            }
        }

        return balance == 0;
    }
}



//Method 2

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> validCombinations = new ArrayList<>();
        generateValidCombinations(new char[2 * n], 0, 0, 0, validCombinations, n);
        return validCombinations;
    }

    private void generateValidCombinations(char[] currentCombination, int index, int openUsedSoFar, int closeUsedSoFar, List<String> validCombinations, int n) {
        if (index == currentCombination.length) {
            validCombinations.add(new String(currentCombination));
            return;
        }

        if (openUsedSoFar < n) {
            currentCombination[index] = '(';
            generateValidCombinations(currentCombination, index + 1, openUsedSoFar + 1, closeUsedSoFar, validCombinations, n);
        }

        if (closeUsedSoFar < openUsedSoFar) {
            currentCombination[index] = ')';
            generateValidCombinations(currentCombination, index + 1, openUsedSoFar, closeUsedSoFar + 1, validCombinations, n);
        }
    }
}


//Aliter

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> validCombinations = new ArrayList<>();
        generateValidCombinations(new StringBuilder(), 0, 0, validCombinations, n);
        return validCombinations;
    }

    private void generateValidCombinations(StringBuilder currentCombination, int openUsedSoFar, int closeUsedSoFar, List<String> validCombinations, int n) {
        if (currentCombination.length() == 2 * n) {
            validCombinations.add(currentCombination.toString());
            return;
        }

        if (openUsedSoFar < n) {
            currentCombination.append('(');
            generateValidCombinations(currentCombination, openUsedSoFar + 1, closeUsedSoFar, validCombinations, n);
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }

        if (closeUsedSoFar < openUsedSoFar) {
            currentCombination.append(')');
            generateValidCombinations(currentCombination, openUsedSoFar, closeUsedSoFar + 1, validCombinations, n);
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }
    }
}
