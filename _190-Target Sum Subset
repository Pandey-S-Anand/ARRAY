//Iterative Approach

//Method 1

//Naive Implementation

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        List<Integer> subsetSums = new ArrayList<>();
        subsetSums.add(0); // Start with the empty subset sum (i.e 0)

        for (int num : arr) {
            int currentSize = subsetSums.size();
            for (int i = 0; i < currentSize; i++) {
                int newSubsetSum = num + subsetSums.get(i);
                if (newSubsetSum == k) {
                    return true;
                }

                subsetSums.add(newSubsetSum);
            }
        }

        return false;
    }
}


//Better Implementation

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        List<Integer> subsetSums = new ArrayList<>();
        subsetSums.add(0); // Start with the empty subset sum (i.e 0)

        for (int num : arr) {
            int currentSize = subsetSums.size();
            for (int i = 0; i < currentSize; i++) {
                int newSubsetSum = num + subsetSums.get(i);
                if (newSubsetSum == k) {
                    return true;
                }
                if (newSubsetSum < k) {
                    subsetSums.add(newSubsetSum);
                }
            }
        }

        return false;
    }
}



//Optimal Implementation

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        List<Integer> subsetSums = new ArrayList<>();
        subsetSums.add(0); // Start with the empty subset sum (i.e 0)

        for (int num : arr) {
            int currentSize = subsetSums.size();
            for (int i = 0; i < currentSize; i++) {
                int newSubsetSum = num + subsetSums.get(i);
                if (newSubsetSum == k) {
                    return true;
                }
                if (!subsetSums.contains(newSubsetSum) && newSubsetSum < k) {
                    subsetSums.add(newSubsetSum);
                }
            }
        }

        return false;
    }
}



//Method 2

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        int totalSubsets = 1 << n; // x << y = x * 2^n

        for (int num = 0; num < totalSubsets; num++) {
            int newSubsetSum = 0;
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    newSubsetSum += arr[i];

                    if (newSubsetSum > k) {
                        break;
                    }
                }
            }

            if (newSubsetSum == k) {
                return true;
            }
        }

        return false;
    }
}


//Method 3

//Naive Implementation

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        //dp[i][j] in indicating whether any subset of the subarray arr[0..i-1] sums to j
        boolean[][] dp = new boolean[n + 1][k + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = true;
                } else if (i == 0) {
                    dp[i][j] = false;
                } else if (j == 0) {
                    dp[i][j] = true;
                } else {
                    if (j >= arr[i - 1]) {
                        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][k];
    }
}


//Improved Approach

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        // dp[i][j] in indicating whether any subset of the subarray arr[0..i-1] sums to target 'j'
        boolean[][] dp = new boolean[n + 1][k + 1];

        dp[0][0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (j == 0) {
                    dp[i][j] = true;
                } else {
                    if (j >= arr[i - 1]) {
                        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][k];
    }
}



//Optimal Approach

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        boolean[] previousRow = new boolean[k + 1];
        boolean[] currentRow = new boolean[k + 1];

        previousRow[0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (j == 0) {
                    currentRow[j] = true;
                } else {
                    if (j >= arr[i - 1]) {
                        currentRow[j] = previousRow[j] || previousRow[j - arr[i - 1]];
                    } else {
                        currentRow[j] = previousRow[j];
                    }
                }
            }

            boolean[] temp = previousRow;
            previousRow = currentRow;
            currentRow = temp;
        }

        return previousRow[k];
    }
}


//Recursive Approach

//Method 1

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        return isTargetSumSubsetPresent(arr, 0, n, k);
    }

    private static boolean isTargetSumSubsetPresent(int[] arr, int index, int n, int targetSum) {
        // Base case: if targetSum is reduced to 0, we have found a subset with the desired sum
        if (targetSum == 0) {
            return true;
        }

        /*
         * Base case (index == n): if we have considered all elements and still unable
         * to find target sum subset
         * Early Termination (target < 0): Since the array contains only positive
         * integers, once the target becomes negative during the recursive exploration, 
         * it will always remain negative for that path. Hence, further exploration of 
         * that path won't yield a valid combination.
         */
        if (index == n || targetSum < 0) {
            return false;
        }

        // Include the current element and check if it leads to the target sum
        boolean include = isTargetSumSubsetPresent(arr, index + 1, n, targetSum - arr[index]);

        // Exclude the current element and check if it leads to the target sum
        boolean exclude = isTargetSumSubsetPresent(arr, index + 1, n, targetSum);

        // Return true if either including or excluding the current element yields the target sum
        return include || exclude;
    }
}


//Method 2

public class Solution {
    public static boolean subsetSumToK(int n, int k, int arr[]) {
        return isTargetSumSubsetPresent(arr, 0, n, k);
    }

    private static boolean isTargetSumSubsetPresent(int[] arr, int index, int n, int targetSum) {
        if (targetSum == 0) {
            return true;
        }

        if (targetSum < 0) {
            return false;
        }

        for (int i = index; i < n; i++) {
            if (isTargetSumSubsetPresent(arr, i + 1, n, targetSum - arr[i])) {
                return true;
            }
        }

        return false;
    }
}
