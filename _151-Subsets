//Iterative Approach

/*
For arr[] = {1, 2, 3}:

Intially:  subsets :[[]].  (Add an empty subset)

Iteration 1: (arr[0]=1)
Pair 1 with all existing subsets i.e [1]
subsets: [[],[1]]

Iteration 2: (arr[1]=2)
Pair 2 with all existing subsets i.e  [2] and [1, 2]  
subsets: [[], [1], [2], [1, 2]].

Iteration 3: (arr[2]=3)
Pair 3 with all existing subsets i.e [3], [1, 3] , [2, 3] and [1, 2, 3]
subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]].
*/

class Solution {
    public List<List<Integer>> subsets(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        subsets.add(new ArrayList<>()); // Start with the empty subset

        for (int val : arr) {
            int size = subsets.size();
            for (int i = 0; i < size; i++) {
                // Create a new subset from the existing subsets by adding the current number to it
                List<Integer> subset = new ArrayList<>(subsets.get(i));
                subset.add(val);
                subsets.add(subset);
            }
        }

        return subsets;
    }
}


//Using Backtracking

/*
[] 
├── [1] //Include 1
│   ├── [1, 2] //Include 2
│   │   ├── [1, 2, 3] //Include 3
│   │   │   ├── [1, 2, 3, 4] //Include 4
│   │   │   └── [1, 2, 3] //Exclude 4
│   │   └── [1, 2] //Exclude 3
│   │       ├── [1, 2, 4] //Include 4
│   │       └── [1, 2] //Exclude 4
│   └── [1] //Exclude 2
│       ├── [1, 3] //Include 3
│       │   ├── [1, 3, 4] //Include 4
│       │   └── [1, 3] //Exclude 4
│       └── [1] //Exclude 3
│           ├── [1, 4] //Include 4
|           └── [1] //Exclude 4
└── [] //Exclude 1
    ├── [2] //Include 2
    │   ├── [2, 3] //Include 3
    │   │   ├── [2, 3, 4] //Include 4
    │   │   └── [2, 3] //Exclude 4
    │   └── [2] //Exclude 3
    │       ├── [2, 4] //Include 4
    │       └── [2]  //Exclude 4
    └── [] //Exclude 2
        ├── [3] //Include 3
        │   ├── [3, 4] //Include 4
        │   └── [3] //Exclude 4
        └── [] //Exclude 3
            ├── [4] //Include 4
            └── [] //Exclude 4

*/


class Solution {
    public List<List<Integer>> subsets(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        List<Integer> subset = new ArrayList<>();

        subset(arr, 0, subset, subsets);
        return subsets;
    }

    private void subset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        /*
         * When index equals arr.length, it means we have processed all elements of the
         * array for the current subset. Thus, we add the current subset to subsets.
         */
        if (index == arr.length) {
            subsets.add(new ArrayList<>(subset)); // Adds a copy of subset (to prevent reference issues) to subsets.
        } else {
            // current element (arr[index]) is added to the subset
            subset.add(arr[index]);
            // explore the path where the current element is included
            subset(arr, index + 1, subset, subsets);
            /*
             * Backtracking :After exploring the path where the current element is included,
             * the element is removed from the subset. It reverts the state of subset to
             * what it was before the current element was added, allowing the exploration
             * of the path where the current element is excluded.
             */
            subset.remove(subset.size() - 1);
            // explore the path where the current element is excluded
            subset(arr, index + 1, subset, subsets);
        }
    }
}


//Aliter

class Solution {
    public List<List<Integer>> subsets(int[] arr) {
        List<List<Integer>> subsets = new ArrayList<>();
        List<Integer> subset = new ArrayList<>();

        subset(arr, 0, subset, subsets);
        return subsets;
    }

    private void subset(int[] arr, int index, List<Integer> subset, List<List<Integer>> subsets) {
        /*
         * When index equals arr.length, it means we have processed all elements of the
         * array for the current subset. Thus, we add the current subset to subsets.
         */
        if (index == arr.length) {
            subsets.add(new ArrayList<>(subset)); // Adds a copy of subset (to prevent reference issues) to subsets.
        } else {
            // explore the path where the current element is excluded
            subset(arr, index + 1, subset, subsets);
            // current element (arr[index]) is added to the subset
            subset.add(arr[index]);
            // explore the path where the current element is included
            subset(arr, index + 1, subset, subsets);
            /*
             * Backtracking :After exploring the path where the current element is included,
             * the element is removed from the subset. It reverts the state of subset to
             * what it was before the current element was added
             */
            subset.remove(subset.size() - 1);
        }
    }
}


