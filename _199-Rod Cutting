//Bruteforce Approach

class Solution {
    public int cutRod(int price[], int n) {
        return cutRod(price, n, n);
    }

    private int cutRod(int[] price, int pieceLength, int rodLength) {
        // Base case: If the rod length is zero, no revenue can be generated.
        if (rodLength == 0) {
            return 0;
        }

        /*
         * Base case: If we've exhausted all possible piece lengths but still have some
         * length of rod remaining, return a negative value (Integer.MIN_VALUE) to
         * indicate that no valid cut can be made to use up the remaining rod length.
         */
        if (pieceLength == 0) {
            return Integer.MIN_VALUE;
        }

        // Option 1: Exclude the current piece length and move to the next piece length
        int exclude = cutRod(price, pieceLength - 1, rodLength);
        int include = Integer.MIN_VALUE;

        if (rodLength >= pieceLength) {
            /*
             * Option 2: Include the current piece length if it fits into the remaining rod
             * length. Recursively attempt to cut the rod again using the same piece length
             * to maximize the total value.
             */
            include = cutRod(price, pieceLength, rodLength - pieceLength);
            if (include != Integer.MIN_VALUE) {
                include += price[pieceLength - 1]; // If it's possible to include the current piece, add its value to the total
            }
        }
        // Return the maximum value between including and excluding the current piece length
        return Math.max(include, exclude);
    }
}


//Better Approach

class Solution {
    private int[][] cache;

    public int cutRod(int price[], int n) {
        cache = new int[n + 1][n + 1];
        intializeCache();
        return cutRod(price, n, n);
    }

    private int cutRod(int[] price, int pieceLength, int rodLength) {
        // Base case: If the rod length is zero, no revenue can be generated.
        if (rodLength == 0) {
            return 0;
        }

        /*
         * Base case: If we've exhausted all possible piece lengths but still have some
         * length of rod remaining, return a negative value (Integer.MIN_VALUE) to
         * indicate that no valid cut can be made to use up the remaining rod length.
         */
        if (pieceLength == 0) {
            return Integer.MIN_VALUE;
        }

        if (cache[pieceLength][rodLength] != -1) {
            return cache[pieceLength][rodLength];
        }

        // Option 1: Exclude the current piece length and move to the next piece length
        int exclude = cutRod(price, pieceLength - 1, rodLength);
        int include = Integer.MIN_VALUE;

        if (rodLength >= pieceLength) {
            /*
             * Option 2: Include the current piece length if it fits into the remaining rod
             * length. Recursively attempt to cut the rod again using the same piece length
             * to maximize the total value.
             */
            include = cutRod(price, pieceLength, rodLength - pieceLength);
            if (include != Integer.MIN_VALUE) {
                include += price[pieceLength - 1]; // If it's possible to include the current piece, add its value to the total
            }
        }
        // Return the maximum value between including and excluding the current piece length
        return cache[pieceLength][rodLength] = Math.max(include, exclude);
    }

    private void intializeCache() {
        for (int i = 0; i < cache.length; i++) {
            Arrays.fill(cache[i], -1);
        }
    }
}


//Optimal Approach

//Naive Implementation 

class Solution {
    public int cutRod(int price[], int n) {
        /*
         * dp[i][j] typically represents the maximum revenue that can be obtained by
         * cutting a rod of length j using the first i piece lengths available (i.e.,
         * considering piece lengths from 1 to i).
         */
        int[][] dp = new int[n + 1][n + 1];
        
        dp[0][0]=0;

        for (int pieceLength = 1; pieceLength <= n; pieceLength++) {
            dp[pieceLength][0] = 0;
        }
        
        for (int rodLength = 1; rodLength <= n; rodLength++) {
            dp[0][rodLength] = Integer.MIN_VALUE;
        }

        for (int pieceLength = 1; pieceLength <= n; pieceLength++) {
            for (int rodLength = 1; rodLength <= n; rodLength++) {
                int exclude = dp[pieceLength - 1][rodLength];
                int include = Integer.MIN_VALUE;

                if (rodLength >= pieceLength) {
                    include = dp[pieceLength][rodLength - pieceLength];
                    if (include != Integer.MIN_VALUE) {
                        include += price[pieceLength - 1];
                    }
                }
                dp[pieceLength][rodLength] = Math.max(include, exclude);
            }
        }

        return dp[n][n];
    }
}


//Optimal Implementation

class Solution {
    public int cutRod(int price[], int n) {
        int[][] dp = new int[n + 1][n + 1];
        
        for (int rodLength = 1; rodLength <= n; rodLength++) {
            dp[0][rodLength] = Integer.MIN_VALUE;
        }

        for (int pieceLength = 1; pieceLength <= n; pieceLength++) {
            for (int rodLength = 1; rodLength <= n; rodLength++) {
                int exclude = dp[pieceLength - 1][rodLength];
                int include = Integer.MIN_VALUE;

                if (rodLength >= pieceLength) {
                    include = dp[pieceLength][rodLength - pieceLength];
                    if (include != Integer.MIN_VALUE) {
                        include += price[pieceLength - 1];
                    }
                }
                dp[pieceLength][rodLength] = Math.max(include, exclude);
            }
        }

        return dp[n][n];
    }
}


//Aliter (space optimised)

class Solution {
    public int cutRod(int price[], int n) {
        int[] previousRow=new int[n+1];
        int[] currentRow=new int[n+1];
        
        for (int rodLength = 1; rodLength <= n; rodLength++) {
            previousRow[rodLength] = Integer.MIN_VALUE;
        }

        for (int pieceLength = 1; pieceLength <= n; pieceLength++) {
            for (int rodLength = 1; rodLength <= n; rodLength++) {
                int exclude = previousRow[rodLength];
                int include = Integer.MIN_VALUE;

                if (rodLength >= pieceLength) {
                    include = currentRow[rodLength - pieceLength];
                    if (include != Integer.MIN_VALUE) {
                        include += price[pieceLength - 1];
                    }
                }
                currentRow[rodLength] = Math.max(include, exclude);
            }
            int[] temp=currentRow;
            currentRow=previousRow;
            previousRow=temp;
        }

        return previousRow[n];
    }
}


//Aliter (further space optimised)

class Solution {
    public int cutRod(int price[], int n) {
        int[] dp = new int[n + 1];

        for (int rodLength = 1; rodLength <= n; rodLength++) {
            dp[rodLength] = Integer.MIN_VALUE;
        }

        for (int pieceLength = 1; pieceLength <= n; pieceLength++) {
            for (int rodLength = 1; rodLength <= n; rodLength++) {
                int exclude = dp[rodLength];
                int include = Integer.MIN_VALUE;

                if (rodLength >= pieceLength) {
                    include = dp[rodLength - pieceLength];
                    if (include != Integer.MIN_VALUE) {
                        include += price[pieceLength - 1];
                    }
                }
                dp[rodLength] = Math.max(include, exclude);
            }
        }

        return dp[n];
    }
}
