//Bruteforce Approach

public class Solution {
  public static int[] nearlySorted(int[] arr, int n, int k) {
    Arrays.sort(arr);
    return arr;
  }
}

/*
Given,
k=3; and int[]arr = {6, 5, 3, 2, 8, 10, 9};

int[]sorted={2, 3, 5, 6, 8, 9, 10};

=>For ‘i’th index element, range in a sorted array will be:
    
  (i-k) <= i <= (i+k)


For i=0, arr[0] i.e 6 range will be : i <= 3
For i=1, arr[1] i.e 5 range will be : 0<= i <= 4
For i=2, arr[2] i.e 3 range will be : 0<= i <= 5
For i=3, arr[3] i.e 2 range will be : 0<= i <= 6
For i=4, arr[4] i.e 8 range will be : 1<= i <= 7
For i=5, arr[5] i.e 10 range will be : 2<= i <= 8
For i=6, arr[6] i.e 9 range will be : 3<= i <= 9
*/

//Optimal Approach

public class Solution {
    public static int[] nearlySorted(int[] arr, int n, int k) {
        Queue<Integer> minHeap = new PriorityQueue<>();
        int index = 0;

        for (int i = 0; i < k; i++) {
            minHeap.add(arr[i]);
        }

        for (int i = k; i < n; i++) {
            minHeap.add(arr[i]);
            arr[index++] = minHeap.peek();
            minHeap.poll();
        }

        while (!minHeap.isEmpty()) {
            arr[index++] = minHeap.poll();
        }

        return arr;
    }
}
