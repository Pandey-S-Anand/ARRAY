//Bruteforce Approach

class Solution {
    public int uniquePaths(int m, int n) {
        // Start the recursive function from the top-left corner of the grid (0,0)
        return uniquePaths(0, 0, m, n);
    }

    private int uniquePaths(int row, int col, int m, int n) {
        // Base case: if we've reached the destination, return 1
        if (row == m - 1 && col == n - 1) {
            return 1;
        }
        /*
         * Recursive Case:
         * - To find the number of ways to reach the bottom-right corner (grid[m - 1][n- 1]) from the top-left corner (grid[0][0]), you have two possible moves:
         *
         * 1. Move right to the next cell [i][j+1]. For example, from [0][0] to [0][1].
         * - Once you move right, we need to calculate the number of ways to reach the
         *   bottom-right corner (grid[m - 1][n - 1]) starting from the new position [0][1].
         *   This is done by calling `uniquePaths(row, col+1)`.
         *
         * 2. Move down to the next cell [i+1][j]. For example, from [0][0] to [1][0].
         * - After moving down, we calculate the number of ways to reach the
         *.  bottom-right corner (grid[m - 1][n - 1]) starting from [1][0].
         *   This is done by calling `uniquePaths(row+1, col)`.
         *
         * After calculating the number of ways to reach the bottom-right corner from
         * both right (uniquePaths(row, col+1)) and down (uniquePaths(row+1, col)),
         * you add the results of these two paths. This allows you to accumulate all
         * possible paths to the destination.
         * Essentially, the recursive process finds all paths to the next right or down
         * cell, and then adds the current step (right or down)
         * to extend those paths until the bottom-right corner is reached.
         */
        int moveRight = 0;
        if (col + 1 < n) {
            // If it's possible to move right (i.e., within grid boundaries), move right and recursively calculate paths
            moveRight = uniquePaths(row, col + 1, m, n);
        }

        int moveDown = 0;
        if (row + 1 < m) {
            // If it's possible to move down (i.e., within grid boundaries), move down and recursively calculate paths
            moveDown = uniquePaths(row + 1, col, m, n);
        }
        
         // Return all possible ways to reach the bottom-right corner from the current cell.
        return moveRight + moveDown;
    }
}


//Better Approach

